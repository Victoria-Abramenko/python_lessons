# # # ______  Задание 163  ______
# # На вход программе подаются целые числа, записанные через пробел. Необходимо их прочитать и с помощью list
# # comprehension сформировать двумерный список lst размером N x N (квадратную таблицу чисел). Гарантируется, что из набора
# # введенных чисел можно сформировать квадратную матрицу (таблицу). Полученный двумерный список отобразить командой:
# # print(lst)
# numbers = list(map(int, input().split()))  # 1 2 3 4 5 6 7 8 9
# n = int(len(numbers) ** 0.5)
# lst = [numbers[i * n: i * n + n] for i in range(n)]
# print(lst)

# # другое интересное решение
# numbers = list(map(int, input().split()))  # 1 2 3 4 5 6 7 8 9
# n = int(len(numbers) ** 0.5)
# it = iter(numbers)
# lst = [[next(it) for j in range(n)] for i in range(n)]
# print(lst)

# # # ______  Задание 164  ______
# # Объявите в программе следующий список из строк:
# # t = ["– Скажи-ка, дядя, ведь не даром",
# #     "Я Python выучил с каналом",
# #     "Балакирев что раздавал?",
# #     "Ведь были ж заданья боевые,",
# #     "Да, говорят, еще какие!",
# #     "Недаром помнит вся Россия",
# #     "Как мы рубили их тогда!"
# #     ]
# # Необходимо преобразовать его в двумерный (вложенный) список lst, где каждая строка представляется списком из слов
# # (слова разделяются пробелом), но сохранять слова только длиной более трех символов. Решить данную задачу следует с
# # использованием list comprehension. Результат отобразить с помощью команды:
# # print(lst)
# # То есть, на выходе список должен быть:
# # [['Скажи-ка,', 'дядя,', 'ведь', 'даром'], ...]
# t = ["– Скажи-ка, дядя, ведь не даром",
#     "Я Python выучил с каналом",
#     "Балакирев что раздавал?",
#     "Ведь были ж заданья боевые,",
#     "Да, говорят, еще какие!",
#     "Недаром помнит вся Россия",
#     "Как мы рубили их тогда!"
#     ]
# lst = [[x for x in i.split() if len(x) > 3
# ] for i in t]
# print(lst)

# # # ______  Задание 165  ______
# #  Повторите задачу с транспонированием прямоугольной матрицы с помощью list comprehension, изложенной в видео-уроке
# #  к этой практике. На вход программе поступает таблица целых чисел, чтение которой уже реализовано в программе:
# # s = sys.stdin.readlines()
# # lst_in = [list(map(int, x.strip().split())) for x in s]
# # Нужно транспонировать список lst_in (строки заменяются на столбцы) и результат сохранить в списке A. Отобразите
# # полученный список A с помощью следующей конструкции:
# # for row in A:
# #     print(*row)
# # Желательно сделать эту задачу не пересматривая видео.
# lst_in = [[1, 2, 3],
#      [4, 5, 6],
#      [7, 8, 9],
#      [5, 4, 3]]
#
# A = [[row[i] for row in lst_in]
#      for i in range(len(lst_in[0]))
# ]
# for row in A:
#     print(*row)
# # 1 4 7 5
# # 2 5 8 4
# # 3 6 9 3

# # # ______  Задание 166  ______
# #  На вход программе подаются данные в формате ключ=значение, записанные через пробел. Значениями здесь являются целые
# #  числа (см. пример ниже). Необходимо прочитать строку с этими данными и на их основе сформировать словарь d, используя
# #  функцию dict(). Результирующий словарь вывести на экран командой:
# # print(*sorted(d.items()))
# lst = list(input().split())  # one=1 two=2 three=3
# lst_1 = [i.split('=') for i in lst]
# for i in range(len(lst_1)):
#     for j in range(2):
#         if j == 1:
#             lst_1[i][j] = int(lst_1[i][j])
# d = dict(lst_1)
# print(*sorted(d.items()))  # ('one', 1) ('three', 3) ('two', 2)

# # # ______  Задание 167  ______
# # На вход программе поступают данные в виде набора строк в формате:
# # ключ1=значение1
# # ключ2=значение2
# # ...
# # ключN=значениеN
# # Ключами здесь выступают целые числа (см. пример ниже). В программе уже реализовано считывание всех строк и сохранение
# # их в виде списка:
# # lst_in = list(map(str.strip, sys.stdin.readlines()))
# # Необходимо преобразовать список lst_in в словарь d (без использования функции dict()) и вывести полученный словарь на
# # экран командой:
# # print(*sorted(d.items()))
# lst_in = ['5=отлично', '4=хорошо', '3=удовлетворительно']
# lst_in  = [i.split('=') for i in lst_in]
# for i in range(len(lst_in)):
#     for j in range(2):
#         if j == 0:
#             lst_in[i][j] = int(lst_in[i][j])
# d = dict(lst_in)
# print(*sorted(d.items()))

# # # ______  Задание 168  ______
# # На вход программе подаются данные в формате ключ=значение, записанные через пробел. Необходимо прочитать строку с
# # этими данными и на их основе сформировать словарь. Затем проверить, существуют ли в словаре ключи со значениями:
# # 'house', 'True' и '5' (все ключи - строки). Если все они существуют, то вывести на экран "ДА", иначе "НЕТ".
# lst_in = list(input().split())  # вологда=город house=дом True=1 5=отлично 9=божественно
# lst_1 = [i.split('=') for i in lst_in]
# d = dict(lst_1)
# if 'house' in d and 'True' in d and '5' in d:
#     print('ДА')
# else:
#     print('НЕТ')
# # ДА

# # # ______  Задание 170  ______
# # На вход программе подаются данные в формате ключ=значение, записанные через пробел. Необходимо прочитать строку с этими
# # данными и на их основе сформировать словарь d. Затем удалить из этого словаря ключи 'False' и '3', если они существуют.
# # Ключами и значениями словаря являются строки. Вывести полученный словарь на экран командой:
# # print(*sorted(d.items()))
# lst_in = [i.split('=') for i in input().split()] # лена=имя дон=река москва=город False=ложь 3=удовлетворительно True=истина
# d = dict(i for i in lst_in)
# if 'False' in d:
#     del d['False']
# if '3' in d:
#     del d['3']
# print(*sorted(d.items()))  # ('True', 'истина') ('дон', 'река') ('лена', 'имя') ('москва', 'город')

# # # ______  Задание 171  ______
# # На вход программе подаются номера телефонов, записанные в одну строчку через пробел, с разными кодами стран: +7, +6,
# # +2, +4 и т.д. Необходимо прочитать строку и на ее основе сформировать словарь d. Ключами словаря должны быть коды
# # (строки: +7, +6, +2 и т. п.), а значениями список номеров в виде строк (следующих в том же порядке, что и в исходной
# # строке) с соответствующими кодами. Полученный словарь вывести командой:
# # print(*sorted(d.items()))
# numbers = [[i[0:2], i] for i in input().split()]# +71234567890 +71234567854 +61234576890 +52134567890 +21235777890 +21234567110 +71232267890
# d = {}
# for i in numbers:
#     if i[0] in d:
#         d[i[0]].append(i[1])
#     else:
#         d[i[0]] = [i[1]]
#
# print(*sorted(d.items())) # ('+2', ['+21235777890', '+21234567110']) ('+5', ['+52134567890']) ('+6', ['+61234576890']) ('+7', ['+71234567890', '+71234567854', '+71232267890'])

# # интересное решение другого ученика
# n = input().split()
# d = dict([(x[:2], [i for i in n if x[:2] == i[:2]]) for x in n])
# print(*sorted(d.items()))

# # # ______  Задание 172  ______
# # На вход программе поступают номера телефонов с привязкой к именам в виде строк следующего формата:
# # номер_1 имя_1
# # номер_2 имя_2
# # ...
# # номер_N имя_N
# # В программе уже реализовано считывание всех строк и сохранение их в виде списка:
# # lst_in = list(map(str.strip, sys.stdin.readlines()))
# # На основе списка lst_in необходимо создать словарь d, где ключами будут имена, а значениями - список номеров телефонов
# # для этого имени (ключа). Обратите внимание, что одному имени может принадлежать несколько разных номеров. Полученный
# # словарь вывести командой:
# # print(*sorted(d.items()))
# lst_in = ['+71234567890 Сергей',
#           '+71234567810 Сергей',
#           '+51234567890 Михаил',
#           '+72134567890 Николай']
# d = {}
# for i in lst_in:
#     i = i.split()
#     if i[1] in d:
#         d[i[1]].append(i[0])
#     else:
#         d[i[1]] = [i[0]]
# print(*sorted(d.items()))

# # интересное решение другого ученика
# import sys
#
# # считывание списка из входного потока
# lst_in = list(map(str.strip, sys.stdin.readlines()))
# d = {}
#
# for i in lst_in:
#     value, key = i.split()
#     if key in d:
#         d[key] += [value]
#     else:
#         d[key] = [value]
#
# print(*sorted(d.items()))

# # # ______  Задание 173  ______
# # На вход программе поступают целые положительные числа. Необходимо с помощью цикла реализовать их считывание,
# # пока не встретится число 0. В теле цикла для каждого прочитанного числа вычисляется квадратный корень
# # (с точностью до сотых) и значение выводится на экран (в столбик). С помощью словаря выполните кэширование данных так,
# # чтобы при повторном вводе того же самого числа результат не вычислялся, а бралось ранее вычисленное значение (из словаря).
# # При этом на экране должно выводиться:
# # значение из кэша: <число>
# n = 1
# d = {}
# s = 0
# while n != 0:
#     n = int(input())  # 1 2 3 3 4 0
#     if n == 0:
#         break
#     if n not in d:
#         d[n] = round(n ** 0.5, 2)
#         print(d[n])
#     else:
#         print(f'значение из кэша: {d[n]}')

# # # ______  Задание 174  ______
# # Тестовый веб-сервер возвращает HTML-страницы по URL-адресам (строкам). На вход программе поступают различные URL-адреса,
# # записанные каждое с новой строки. В программе уже реализовано считывание всех строк и сохранение их в виде списка:
# # lst_in = list(map(str.strip, sys.stdin.readlines()))
# # Необходимо перебрать в цикле этот список с URL-адресами и если адрес появился (пришел) впервые, то на экране отобразить
# # строку (без кавычек):
# # "HTML-страница для адреса <URL-адрес>"
# # и сохранить в словаре эту строку с ключом текущего URL-адреса. Если же URL-адрес встречается (приходит) повторно
# # (проверяется по ключам словаря), то следует взять строку "HTML-страница для адреса <URL-адрес>" из этого словаря и
# # вывести на экран сообщение (без кавычек):
# # "Взято из кэша: HTML-страница для адреса <URL-адрес>"
# # Сообщения выводить каждое с новой строки.
# # P.S. Подобные задачи на практике решаются через хэш-таблицы. В Python словарь - это хэш-таблица. Скорость поиска ключа
# # в нем выполняется очень быстро (намного быстрее, чем в списке). Именно поэтому решать ее через список очень плохая практика.
# lst_in = ['ustanovka-i-zapusk-yazyka', 'ustanovka-i-poryadok-raboty-pycharm',
#           'peremennyye-operator-prisvaivaniya-tipy-dannykh', 'arifmeticheskiye-operatsii',
#           'ustanovka-i-poryadok-raboty-pycharm']
# d = {}
# for i in lst_in:
#     if i in d:
#         print(f'Взято из кэша: {d[i]}')
#     else:
#         my_str = f'HTML-страница для адреса {i}'
#         print(my_str)
#         d[i] = my_str

# # # ______  Задание 175  ______
# # На вход программе подается строка из русских букв и символов пробела. Необходимо ее прочитать и закодировать азбукой
# # Морзе, где каждой букве ставится в соответствие код из точки и тире. После каждой закодированной буквы должен стоять
# # пробел (символ окончания кода буквы). После последнего кода пробела быть не должно (в конце строки). Коды азбуки Морзе
# # приведены ниже для русского алфавита и символа пробела:
# # А    .-	М    --	Ш    ----
# # Б    -...	Н    -.	Щ    --.-
# # В    .--	О    ---	Ъ    --.--
# # Г    --.	П    .--.	Ы    -.--
# # Д    -..	Р    .-.	Ь    -..-
# # Е (Ё)    .	С    ...	Э    ..-..
# # Ж    ...-	Т    -	Ю    ..--
# # З    --..	У    ..-	Я    .-.-
# # И    ..	Ф    ..-.	' '    -...-
# # Й    .---	Х    ....
# # К    -.-	Ц    -.-.
# # Л    .-..	Ч    ---.
# # Результат кодирования вывести в виде строки.
# morze = {'а': '.-', 'б': '-...', 'в': '.--', 'г': '--.', 'д': '-..', 'е': '.', 'ё': '.', 'ж': '...-', 'з': '--..',
#          'и': '..', 'й': '.---', 'к': '-.-', 'л': '.-..', 'м': '--', 'н': '-.', 'о': '---', 'п': '.--.', 'р': '.-.',
#          'с': '...', 'т': '-', 'у': '..-', 'ф': '..-.', 'х': '....', 'ц': '-.-.', 'ч': '---.', 'ш': '----',
#          'щ': '--.-', 'ъ': '--.--', 'ы': '-.--', 'ь': '-..-', 'э': '..-..', 'ю': '..--', 'я': '.-.-', ' ': '-...-'}
#
# str_in = list(input().lower())
# lst = [morze.get(i) for i in str_in]
# print(*lst)  # ... . .-. --. . .--- -...- -... .- .-.. .- -.- .. .-. . .--


