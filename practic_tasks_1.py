# # # ______  Задание 163  ______
# # На вход программе подаются целые числа, записанные через пробел. Необходимо их прочитать и с помощью list
# # comprehension сформировать двумерный список lst размером N x N (квадратную таблицу чисел). Гарантируется, что из набора
# # введенных чисел можно сформировать квадратную матрицу (таблицу). Полученный двумерный список отобразить командой:
# # print(lst)
# numbers = list(map(int, input().split()))  # 1 2 3 4 5 6 7 8 9
# n = int(len(numbers) ** 0.5)
# lst = [numbers[i * n: i * n + n] for i in range(n)]
# print(lst)

# # другое интересное решение
# numbers = list(map(int, input().split()))  # 1 2 3 4 5 6 7 8 9
# n = int(len(numbers) ** 0.5)
# it = iter(numbers)
# lst = [[next(it) for j in range(n)] for i in range(n)]
# print(lst)

# # # ______  Задание 164  ______
# # Объявите в программе следующий список из строк:
# # t = ["– Скажи-ка, дядя, ведь не даром",
# #     "Я Python выучил с каналом",
# #     "Балакирев что раздавал?",
# #     "Ведь были ж заданья боевые,",
# #     "Да, говорят, еще какие!",
# #     "Недаром помнит вся Россия",
# #     "Как мы рубили их тогда!"
# #     ]
# # Необходимо преобразовать его в двумерный (вложенный) список lst, где каждая строка представляется списком из слов
# # (слова разделяются пробелом), но сохранять слова только длиной более трех символов. Решить данную задачу следует с
# # использованием list comprehension. Результат отобразить с помощью команды:
# # print(lst)
# # То есть, на выходе список должен быть:
# # [['Скажи-ка,', 'дядя,', 'ведь', 'даром'], ...]
# t = ["– Скажи-ка, дядя, ведь не даром",
#     "Я Python выучил с каналом",
#     "Балакирев что раздавал?",
#     "Ведь были ж заданья боевые,",
#     "Да, говорят, еще какие!",
#     "Недаром помнит вся Россия",
#     "Как мы рубили их тогда!"
#     ]
# lst = [[x for x in i.split() if len(x) > 3
# ] for i in t]
# print(lst)

# # # ______  Задание 165  ______
# #  Повторите задачу с транспонированием прямоугольной матрицы с помощью list comprehension, изложенной в видео-уроке
# #  к этой практике. На вход программе поступает таблица целых чисел, чтение которой уже реализовано в программе:
# # s = sys.stdin.readlines()
# # lst_in = [list(map(int, x.strip().split())) for x in s]
# # Нужно транспонировать список lst_in (строки заменяются на столбцы) и результат сохранить в списке A. Отобразите
# # полученный список A с помощью следующей конструкции:
# # for row in A:
# #     print(*row)
# # Желательно сделать эту задачу не пересматривая видео.
# lst_in = [[1, 2, 3],
#      [4, 5, 6],
#      [7, 8, 9],
#      [5, 4, 3]]
#
# A = [[row[i] for row in lst_in]
#      for i in range(len(lst_in[0]))
# ]
# for row in A:
#     print(*row)
# # 1 4 7 5
# # 2 5 8 4
# # 3 6 9 3

# # # ______  Задание 166  ______
# #  На вход программе подаются данные в формате ключ=значение, записанные через пробел. Значениями здесь являются целые
# #  числа (см. пример ниже). Необходимо прочитать строку с этими данными и на их основе сформировать словарь d, используя
# #  функцию dict(). Результирующий словарь вывести на экран командой:
# # print(*sorted(d.items()))
# lst = list(input().split())  # one=1 two=2 three=3
# lst_1 = [i.split('=') for i in lst]
# for i in range(len(lst_1)):
#     for j in range(2):
#         if j == 1:
#             lst_1[i][j] = int(lst_1[i][j])
# d = dict(lst_1)
# print(*sorted(d.items()))  # ('one', 1) ('three', 3) ('two', 2)

# # # ______  Задание 167  ______
# # На вход программе поступают данные в виде набора строк в формате:
# # ключ1=значение1
# # ключ2=значение2
# # ...
# # ключN=значениеN
# # Ключами здесь выступают целые числа (см. пример ниже). В программе уже реализовано считывание всех строк и сохранение
# # их в виде списка:
# # lst_in = list(map(str.strip, sys.stdin.readlines()))
# # Необходимо преобразовать список lst_in в словарь d (без использования функции dict()) и вывести полученный словарь на
# # экран командой:
# # print(*sorted(d.items()))
# lst_in = ['5=отлично', '4=хорошо', '3=удовлетворительно']
# lst_in  = [i.split('=') for i in lst_in]
# for i in range(len(lst_in)):
#     for j in range(2):
#         if j == 0:
#             lst_in[i][j] = int(lst_in[i][j])
# d = dict(lst_in)
# print(*sorted(d.items()))

# # # ______  Задание 168  ______
# # На вход программе подаются данные в формате ключ=значение, записанные через пробел. Необходимо прочитать строку с
# # этими данными и на их основе сформировать словарь. Затем проверить, существуют ли в словаре ключи со значениями:
# # 'house', 'True' и '5' (все ключи - строки). Если все они существуют, то вывести на экран "ДА", иначе "НЕТ".
# lst_in = list(input().split())  # вологда=город house=дом True=1 5=отлично 9=божественно
# lst_1 = [i.split('=') for i in lst_in]
# d = dict(lst_1)
# if 'house' in d and 'True' in d and '5' in d:
#     print('ДА')
# else:
#     print('НЕТ')
# # ДА

# # # ______  Задание 170  ______
# # На вход программе подаются данные в формате ключ=значение, записанные через пробел. Необходимо прочитать строку с этими
# # данными и на их основе сформировать словарь d. Затем удалить из этого словаря ключи 'False' и '3', если они существуют.
# # Ключами и значениями словаря являются строки. Вывести полученный словарь на экран командой:
# # print(*sorted(d.items()))
# lst_in = [i.split('=') for i in input().split()] # лена=имя дон=река москва=город False=ложь 3=удовлетворительно True=истина
# d = dict(i for i in lst_in)
# if 'False' in d:
#     del d['False']
# if '3' in d:
#     del d['3']
# print(*sorted(d.items()))  # ('True', 'истина') ('дон', 'река') ('лена', 'имя') ('москва', 'город')

# # # ______  Задание 171  ______
# # На вход программе подаются номера телефонов, записанные в одну строчку через пробел, с разными кодами стран: +7, +6,
# # +2, +4 и т.д. Необходимо прочитать строку и на ее основе сформировать словарь d. Ключами словаря должны быть коды
# # (строки: +7, +6, +2 и т. п.), а значениями список номеров в виде строк (следующих в том же порядке, что и в исходной
# # строке) с соответствующими кодами. Полученный словарь вывести командой:
# # print(*sorted(d.items()))
# numbers = [[i[0:2], i] for i in input().split()]# +71234567890 +71234567854 +61234576890 +52134567890 +21235777890 +21234567110 +71232267890
# d = {}
# for i in numbers:
#     if i[0] in d:
#         d[i[0]].append(i[1])
#     else:
#         d[i[0]] = [i[1]]
#
# print(*sorted(d.items())) # ('+2', ['+21235777890', '+21234567110']) ('+5', ['+52134567890']) ('+6', ['+61234576890']) ('+7', ['+71234567890', '+71234567854', '+71232267890'])

# # интересное решение другого ученика
# n = input().split()
# d = dict([(x[:2], [i for i in n if x[:2] == i[:2]]) for x in n])
# print(*sorted(d.items()))

# # # ______  Задание 172  ______
# # На вход программе поступают номера телефонов с привязкой к именам в виде строк следующего формата:
# # номер_1 имя_1
# # номер_2 имя_2
# # ...
# # номер_N имя_N
# # В программе уже реализовано считывание всех строк и сохранение их в виде списка:
# # lst_in = list(map(str.strip, sys.stdin.readlines()))
# # На основе списка lst_in необходимо создать словарь d, где ключами будут имена, а значениями - список номеров телефонов
# # для этого имени (ключа). Обратите внимание, что одному имени может принадлежать несколько разных номеров. Полученный
# # словарь вывести командой:
# # print(*sorted(d.items()))
# lst_in = ['+71234567890 Сергей',
#           '+71234567810 Сергей',
#           '+51234567890 Михаил',
#           '+72134567890 Николай']
# d = {}
# for i in lst_in:
#     i = i.split()
#     if i[1] in d:
#         d[i[1]].append(i[0])
#     else:
#         d[i[1]] = [i[0]]
# print(*sorted(d.items()))

# # интересное решение другого ученика
# import sys
#
# # считывание списка из входного потока
# lst_in = list(map(str.strip, sys.stdin.readlines()))
# d = {}
#
# for i in lst_in:
#     value, key = i.split()
#     if key in d:
#         d[key] += [value]
#     else:
#         d[key] = [value]
#
# print(*sorted(d.items()))

# # # ______  Задание 173  ______
# # На вход программе поступают целые положительные числа. Необходимо с помощью цикла реализовать их считывание,
# # пока не встретится число 0. В теле цикла для каждого прочитанного числа вычисляется квадратный корень
# # (с точностью до сотых) и значение выводится на экран (в столбик). С помощью словаря выполните кэширование данных так,
# # чтобы при повторном вводе того же самого числа результат не вычислялся, а бралось ранее вычисленное значение (из словаря).
# # При этом на экране должно выводиться:
# # значение из кэша: <число>
# n = 1
# d = {}
# s = 0
# while n != 0:
#     n = int(input())  # 1 2 3 3 4 0
#     if n == 0:
#         break
#     if n not in d:
#         d[n] = round(n ** 0.5, 2)
#         print(d[n])
#     else:
#         print(f'значение из кэша: {d[n]}')

# # # ______  Задание 174  ______
# # Тестовый веб-сервер возвращает HTML-страницы по URL-адресам (строкам). На вход программе поступают различные URL-адреса,
# # записанные каждое с новой строки. В программе уже реализовано считывание всех строк и сохранение их в виде списка:
# # lst_in = list(map(str.strip, sys.stdin.readlines()))
# # Необходимо перебрать в цикле этот список с URL-адресами и если адрес появился (пришел) впервые, то на экране отобразить
# # строку (без кавычек):
# # "HTML-страница для адреса <URL-адрес>"
# # и сохранить в словаре эту строку с ключом текущего URL-адреса. Если же URL-адрес встречается (приходит) повторно
# # (проверяется по ключам словаря), то следует взять строку "HTML-страница для адреса <URL-адрес>" из этого словаря и
# # вывести на экран сообщение (без кавычек):
# # "Взято из кэша: HTML-страница для адреса <URL-адрес>"
# # Сообщения выводить каждое с новой строки.
# # P.S. Подобные задачи на практике решаются через хэш-таблицы. В Python словарь - это хэш-таблица. Скорость поиска ключа
# # в нем выполняется очень быстро (намного быстрее, чем в списке). Именно поэтому решать ее через список очень плохая практика.
# lst_in = ['ustanovka-i-zapusk-yazyka', 'ustanovka-i-poryadok-raboty-pycharm',
#           'peremennyye-operator-prisvaivaniya-tipy-dannykh', 'arifmeticheskiye-operatsii',
#           'ustanovka-i-poryadok-raboty-pycharm']
# d = {}
# for i in lst_in:
#     if i in d:
#         print(f'Взято из кэша: {d[i]}')
#     else:
#         my_str = f'HTML-страница для адреса {i}'
#         print(my_str)
#         d[i] = my_str

# # # ______  Задание 175  ______
# # На вход программе подается строка из русских букв и символов пробела. Необходимо ее прочитать и закодировать азбукой
# # Морзе, где каждой букве ставится в соответствие код из точки и тире. После каждой закодированной буквы должен стоять
# # пробел (символ окончания кода буквы). После последнего кода пробела быть не должно (в конце строки). Коды азбуки Морзе
# # приведены ниже для русского алфавита и символа пробела:
# # А    .-	М    --	Ш    ----
# # Б    -...	Н    -.	Щ    --.-
# # В    .--	О    ---	Ъ    --.--
# # Г    --.	П    .--.	Ы    -.--
# # Д    -..	Р    .-.	Ь    -..-
# # Е (Ё)    .	С    ...	Э    ..-..
# # Ж    ...-	Т    -	Ю    ..--
# # З    --..	У    ..-	Я    .-.-
# # И    ..	Ф    ..-.	' '    -...-
# # Й    .---	Х    ....
# # К    -.-	Ц    -.-.
# # Л    .-..	Ч    ---.
# # Результат кодирования вывести в виде строки.
# morze = {'а': '.-', 'б': '-...', 'в': '.--', 'г': '--.', 'д': '-..', 'е': '.', 'ё': '.', 'ж': '...-', 'з': '--..',
#          'и': '..', 'й': '.---', 'к': '-.-', 'л': '.-..', 'м': '--', 'н': '-.', 'о': '---', 'п': '.--.', 'р': '.-.',
#          'с': '...', 'т': '-', 'у': '..-', 'ф': '..-.', 'х': '....', 'ц': '-.-.', 'ч': '---.', 'ш': '----',
#          'щ': '--.-', 'ъ': '--.--', 'ы': '-.--', 'ь': '-..-', 'э': '..-..', 'ю': '..--', 'я': '.-.-', ' ': '-...-'}
#
# str_in = list(input().lower())
# lst = [morze.get(i) for i in str_in]
# print(*lst)  # ... . .-. --. . .--- -...- -... .- .-.. .- -.- .. .-. . .--

# # # # ______  Задание 176  ______
# # На вход программе подается закодированная строка с помощью азбуки Морзе. Коды разделены между собой пробелом.
# # Необходимо ее раскодировать, используя азбуку Морзе из предыдущего занятия. Все буквы в строке должны быть малыми
# # (нижний регистр). Полученное сообщение (строку) вывести на экран.
# morze = {'а': '.-', 'б': '-...', 'в': '.--', 'г': '--.', 'д': '-..', 'е': '.', 'ж': '...-', 'з': '--..', 'и': '..',
#          'й': '.---', 'к': '-.-', 'л': '.-..', 'м': '--', 'н': '-.', 'о': '---', 'п': '.--.', 'р': '.-.', 'с': '...',
#          'т': '-', 'у': '..-', 'ф': '..-.', 'х': '....', 'ц': '-.-.', 'ч': '---.', 'ш': '----', 'щ': '--.-',
#          'ъ': '--.--', 'ы': '-.--', 'ь': '-..-', 'э': '..-..', 'ю': '..--', 'я': '.-.-', ' ': '-...-'}
# lst = []
# str_in = input().split()
#
# for i in str_in:
#     for key, value in morze.items():
#         if i == value:
#             lst.append(key)
#
# print(*lst, sep='')

# # интересное решение другого студента
# morze = {'а': '.-', 'б': '-...', 'в': '.--', 'г': '--.', 'д': '-..', 'е': '.', 'ж': '...-', 'з': '--..', 'и': '..',
# 'й': '.---', 'к': '-.-', 'л': '.-..', 'м': '--', 'н': '-.', 'о': '---', 'п': '.--.', 'р': '.-.', 'с': '...', 'т': '-',
# 'у': '..-', 'ф': '..-.', 'х': '....', 'ц': '-.-.', 'ч': '---.', 'ш': '----', 'щ': '--.-', 'ъ': '--.--', 'ы': '-.--',
# 'ь': '-..-', 'э': '..-..', 'ю': '..--', 'я': '.-.-', ' ': '-···-'}
# back_morze = {v: k for k, v in morze.items()}
# print(*(back_morze[code] for code in input().lower().split()), sep='')

# # интересное решение другого студента
# morze = {'а': '.-', 'б': '-...', 'в': '.--', 'г': '--.', 'д': '-..', 'е': '.', 'ж': '...-', 'з': '--..',
# 'и': '..', 'й': '.---', 'к': '-.-', 'л': '.-..', 'м': '--', 'н': '-.', 'о': '---', 'п': '.--.', 'р': '.-.',
# 'с': '...', 'т': '-', 'у': '..-', 'ф': '..-.', 'х': '....', 'ц': '-.-.', 'ч': '---.', 'ш': '----', 'щ': '--.-',
# ъ': '--.--', 'ы': '-.--', 'ь': '-..-', 'э': '..-..', 'ю': '..--', 'я': '.-.-', ' ': '-...-'}
# s = input().split()
# res = [print(k, end='') for i in s for k,v in morze.items() if i==v]

# # # ______  Задание 177  ______
# # а вход программе подается список целых чисел, записанных в одну строчку через пробел. Необходимо их прочитать и
# # сохранить в виде списка. Затем, с помощью словаря выделите только уникальные (не повторяющиеся) числа. Сформируйте
# # из них еще один список (уникальных чисел). Числа в этом списке должны идти в том же порядке, что и при чтении
# # (из входного потока). Выведите уникальные числа на экран в одну строчку через пробел.
# # P. S. Такая задача, обычно решается через множества, но мы их еще не проходили, поэтому воспользуемся словарем.
# lst_in = [[int(i), 0 ]for i in input().split()]  # 8 11 -4 5 2 11 4 8
# d = dict(lst_in)
# print(*d.keys())  # 8 11 -4 5 2 4

# # интересное решение другого студента
# print(*dict.fromkeys(input().split()))
# # интересное решение другого студента
# print(*{i: None for i in input().split()})

# # ______  Задание 178  ______
# # На вход программе подаются строки в формате:
# # <день рождения 1> имя_1
# # <день рождения 2> имя_2
# # ...
# # <день рождения N> имя_N
# # Дни рождений и имена могут повторяться.
# # В программе уже реализовано их считывание и сохранение в списке:
# # lst_in = list(map(str.strip, sys.stdin.readlines()))
# # На основе списка lst_in сформировать словарь, где ключи - дни рождения (целое число), а значения - имена (строка).
# # Выведите полученный словарь в формате (см. пример ниже):
# # день рождения 1: имя1, ..., имяN1
# # день рождения 2: имя1, ..., имяN2
# # ...
# # день рождения M: имя1, ..., имяNM
# import sys
#
# # считывание списка из входного потока
# lst_in = list(map(str.strip, sys.stdin.readlines()))
#
# # здесь продолжайте программу (используйте список lst_in)
# d = {}
# lst_2 = [i.split() for i in lst_in]
# for i in range(len(lst_2)):
#     if lst_2[i][0] in d:
#         d[lst_2[i][0]] = f'{d[lst_2[i][0]]}, {lst_2[i][1]}'
#     else:
#         d[lst_2[i][0]] = lst_2[i][1]
#
# for key, value in d.items():
#     print(f'{key}: {value}')

# # ______  Задание 179  ______
# # Объявите в программе словарь с наименованиями предметов и их весом (в граммах):
# # things = {'карандаш': 20, 'зеркальце': 100, 'зонт': 500, 'рубашка': 300,
# #           'брюки': 1000, 'бумага': 200, 'молоток': 600, 'пила': 400, 'удочка': 1200,
# #           'расческа': 40, 'котелок': 820, 'палатка': 5240, 'брезент': 2130, 'спички': 10}
# # Сергей собирается в поход и готов взвалить на свои хрупкие плечи максимальный вес в N кг (вводится с клавиатуры).
# # Он решил класть в рюкзак предметы в порядке убывания их веса (сначала самые тяжелые, затем, все более легкие) так,
# # чтобы их суммарный вес не превысил значения N кг. Все предметы даны в единственном экземпляре. Выведите список
# # предметов (в строчку через пробел), которые берет с собой Сергей в порядке убывания их веса.
# things = {'карандаш': 20, 'зеркальце': 100, 'зонт': 500, 'рубашка': 300,
#           'брюки': 1000, 'бумага': 200, 'молоток': 600, 'пила': 400, 'удочка': 1200,
#           'расческа': 40, 'котелок': 820, 'палатка': 5240, 'брезент': 2130, 'спички': 10}
# n = 1000 * int(input())
# things_weight = sorted(things.values(), reverse=True)
# d = {v: k for k, v in things.items()}
# lst = []
# for i in things_weight:
#     if i <= n:
#         n -= i
#         lst.append(d[i])
# print(*lst)

# # ______  Задание 180  ______
# # Объявите в программе следующий кортеж:
# # t = (3.4, -56.7)
# # На вход программе подается последовательность целых чисел, записанных через пробел. Необходимо их прочитать и добавить
# # в конец кортежа t. Добавленные числа в кортеже должны следовать в порядке их считывания. Результат вывести на экран командой:
# # print(t)
# t = (3.4, -56.7)  # 8 11 -5 2
# numbers = list(map(int, input().split()))
# t += tuple(numbers)
# print(t)  # (3.4, -56.7, 8, 11, -5, 2)

# # ______  Задание 181  ______
# # На вход программе подается строка с названиями городов, записанных через пробел. Необходимо прочитать эту строку и на
# # ее основе сформировать кортеж из названий городов. Названия в кортеже должны идти в том же порядке, что и в исходной строке.
# # Выполните проверку: если в полученном кортеже нет города "Москва", то следует его добавить в конец кортежа. Выведите
# # на экран названия городов из кортежа (по порядку) в одну строчку через пробел.
# t = tuple(input().split())  # Уфа Казань Самара
# if 'Москва' not in t:
#     t += ('Москва',)
# print(*t)  # Уфа Казань Самара Москва

# # ______  Задание 182  ______
# # На вход программе подается строка с названиями городов, записанных через пробел. Необходимо прочитать эту строку и
# # на ее основе сформировать кортеж из названий городов. Затем, выполните проверку: если в полученном кортеже присутствует
# # город "Ульяновск", то этот элемент следует удалить (создав новый кортеж). Выведите на экран названия городов из итогового
# # кортежа (по порядку) в одну строчку через пробел.
# cities = tuple(input().split())  # Воронеж Самара Тольятти Ульяновск Пермь
# if 'Ульяновск' in cities:
#     i = cities.index('Ульяновск')
#     cities = cities[:i] + cities[i + 1:]
# print(*cities)  # Воронеж Самара Тольятти Пермь

# # ______  Задание 183  ______
# #  На вход программе подается строка с именами студентов, записанных через пробел. Необходимо прочитать эту строку и на
# #  ее основе сформировать кортеж из имен. Затем, отобразите на экране все имена малыми буквами из этого кортежа (по порядку),
# #  которые содержат фрагмент "ва" (без учета регистра). Имена выводятся в одну строчку через пробел в нижнем регистре
# #  (малыми буквами).
# names = tuple(input().split())  # Петя Варвара Венера Василиса Василий Федор
# name = tuple()
# for i in names:
#     i = i.lower()
#     if 'ва' in i:
#         name += (i,)
# if name == ():
#     print(*names)
# print(*name) # варвара василиса василий

# # ______  Задание 184  ______
# #  На вход программе подаются целые числа, записанные в одну строку через пробел. Необходимо их прочитать и сохранить
# #  в кортеже. Затем, создать еще один кортеж с уникальными (не повторяющимися) значениями из первого кортежа. Уникальные
# #  числа должны следовать в том же порядке, что и в исходном кортеже. Отобразите найденные уникальные числа в одну
# #  строчку через пробел.
# # P. S. Подобные задачи решаются, как правило, с помощью множеств, но в качестве практики пока обойдемся без них.
# numbers = tuple(map(int, input().split()))  # 8 11 -5 -2 8 11 -5
# new_numbers = ()
# for i in numbers:
#     if i not in new_numbers:
#         new_numbers += (i,)
#
# print(*new_numbers) # 8 11 -5 -2

# # ______  Задание 185  ______
# # На вход программе подаются целые числа, записанные в одну строку через пробел. Необходимо их прочитать и сохранить в
# # кортеже. Затем, в кортеже найти и вывести в одну строчку через пробел (по порядку) все индексы неуникальных
# # (повторяющихся) значений.
# numbers = tuple(map(int, input().split()))  # 5 4 -3 2 4 5 10 11
# index_tuple = ()
# ind = ()
#
# for i, v in enumerate(numbers):
#     if v in index_tuple:
#         if numbers.index(v) not in ind:
#             ind += (numbers.index(v), i)
#         else:
#             ind += (i,)
#     index_tuple += (v,)
# lst = sorted(ind)
# print(*lst)  # 0 1 4 5

# # ______  Задание 186  ______
# # Объявите в программе следующий двумерный кортеж, размером 5 x 5 элементов:
# # t = ((1, 0, 0, 0, 0),
# #      (0, 1, 0, 0, 0),
# #      (0, 0, 1, 0, 0),
# #      (0, 0, 0, 1, 0),
# #      (0, 0, 0, 0, 1))
# # На вход программе подается натуральное число N (N < 5). Необходимо на основе кортежа t сформировать новый аналогичный
# # кортеж t2 размером N x N элементов путем отбрасывания последних строк и столбцов. Результат выведите на экран в виде
# # таблицы чисел.
# # P.S. Обратите внимание, что в при выводе таблицы в конце строк не должно быть пробелов.
# t = ((1, 0, 0, 0, 0),
#      (0, 1, 0, 0, 0),
#      (0, 0, 1, 0, 0),
#      (0, 0, 0, 1, 0),
#      (0, 0, 0, 0, 1))
# t2 = ()
# count = 0
# N = int(input()) # 3
# for i in t:
#     if count < N:
#         t2 += (i[:N],)
#     count += 1
# for i in t2:
#     print(*i)
# # 1 0 0
# # 0 1 0
# # 0 0 1

# # ______  Задание 187  ______
# # На вход программе подаются строки (пункты меню), каждая с новой строки, в формате:
# #
# # название_1 URL-адрес_1
# # название_2 URL-адрес_2
# # ...
# # название_N URL-адрес_N
# # В программе уже реализовано чтение этих строк и сохранение их в списке:
# # lst_in = list(map(str.strip, sys.stdin.readlines()))
# # Необходимо преобразовать список lst_in так, чтобы получился кортеж menu следующего вида:
# # ((название_1, URL-адрес_1), (название_2, URL-адрес_2), ... (название_N, URL-адрес_N))
# # Полученный кортеж вывести на экран командой:
# # print(menu)
# # Главная home
# # Python learn-python
# # Java learn-java
# # PHP learn-php
# import sys
# # считывание списка из входного потока
# lst_in = list(map(str.strip, sys.stdin.readlines()))
# # здесь продолжайте программу (используйте список lst_in)
# menu = tuple([tuple(lst_in[i].split()) for i in range(len(lst_in))])
# print(menu)  # (('Главная', 'home'), ('Python', 'learn-python'), ('Java', 'learn-java'), ('PHP', 'learn-php'))

# # ______  Задание 188  ______
# #  На вход программе подаются вещественные числа, записанные в одну строчку через пробел. Необходимо их прочитать
# #  и сохранить в множестве s.
# # Подсказка: множество можно создать по аналогии со списком:
# # list(map(float, <список из строк чисел>))
# # Выведите на экран значения множества s в порядке возрастания в одну строчку через пробел с помощью команды:
# # print(*sorted(s))
# # P. S. О функции sorted мы еще будем говорить, а также об операторе *. Пока просто запомните такую возможность
# # сортировки и вывода произвольных коллекций на экран.
# s = set(map(float, input().split()))  # -5.1 -3.0 7.6 10.3 -4.6 2.78
# print(*sorted(s))  # -5.1 -4.6 -3.0 2.78 7.6 10.3

# # ______  Задание 189  ______
# # На вход программе подается строка со словами, разделенные пробелом. Необходимо прочитать эту строку, разбить на слова
# # и с помощью множества подсчитать число уникальных слов (без учета регистра). Результат (число уникальных слов) вывести
# # на экран.
# str = set([i.lower() for i in input().split()])  # Мама мыла раму а потом мыла кота и еще мыла пол
# print(len(str))  # 9

# # ______  Задание 190  ______
# # На вход программе подается строка, содержащая латинские символы, пробелы и цифры. Необходимо прочитать эту строку и
# # выделить из нее все неповторяющиеся цифры (символы от 0 до 9). Выведите на экран все найденные уникальные цифры в одну
# # строчку через пробел в порядке возрастания их значений. Если цифры отсутствуют, то вывести строку "НЕТ".
# str = input().split() # Python 3.9.11 - best language!
# s = set()
# for i in str:
#     for j in i:
#         if j.isdigit():
#             s.add(j)
# if s:
#     print(*sorted(s)) # 1 3 9
# else:
#     print('НЕТ')

# # ______  Задание 191  ______
# # В ночном клубе фиксируется список гостей. Причем гости могут выходить из помещения, а затем, снова заходить.
# # Тогда их имена фиксируются повторно. На вход программы поступает такой список (каждое имя записано с новой строки).
# # В программе уже реализовано считывание этих строк и сохранение в списке:
# # lst_in = list(map(str.strip, sys.stdin.readlines()))
# # Требуется подсчитать по списку lst_in общее число гостей, которые посетили ночной клуб. Полагается, что гости имеют
# # уникальные имена. На экран вывести общее число гостей клуба.
# lst_in = ['Мария', 'Елена', 'Екатерина', 'Александр', 'Елена', 'Мария']
# print(len(set(lst_in)))  # 4

# # ______  Задание 192  ______
# # В аккаунте YouTube Сергея прокомментировали очередное видео. Некоторые посетители оставляли несколько комментариев.
# # Требуется по списку комментариев определить уникальное число комментаторов (полагается, что имена у разных комментаторов
# # не совпадают). Комментарии поступают на вход программе в формате:
# # имя 1: комментарий 1
# # имя 2: комментарий 2
# # ...
# # имя N: комментарий N
# # В программе уже реализовано считывание этих строк и сохранение в списке:
# # lst_in = list(map(str.strip, sys.stdin.readlines()))
# # Выведите на экран общее число уникальных комментаторов.
# lst_in = ['EvgeniyK: спасибо большое!', 'LinaTroshka: лайк и подписка!', 'Sergey Karandeev: крутое видео!',
#           'Евгений Соснин: обожаю', 'EvgeniyK: это повтор?', 'Sergey Karandeev: нет, это новое видео']
# names = set()
# for i in lst_in:
#     lst = i.split(':')
#     names.add(lst[0])
# print(len(names))

# # ______  Задание 193  ______
# # На вход программе подаются названия городов, каждое с новой строки. Необходимо в цикле читать эти названия, пока
# # не встретится строка "q". С помощью множества определить общее уникальное число городов, которые читались в программе
# # (за исключением "q"). На экран вывести это число.
# # P.S. Из коллекций при реализации программы использовать только множества.
# # Уфа
# # Москва
# # Тверь
# # Екатеринбург
# # Томск
# # Уфа
# # Москва
# # q
# i = ''
# s = set()
# while i != 'q':
#     i = input()
#     if i == 'q':
#         break
#     s.add(i)
#
# print(len(s))

# # ______  Задание 194  ______
# # На вход программе подаются два списка целых чисел, каждый с новой строки (в строке наборы чисел следующих через пробел).
# # Необходимо прочитать эти наборы чисел и сохранить их в отдельных списках (или кортежах). Затем, с помощью множеств(а)
# # выбрать только уникальные числа, присутствующие и в первом и во втором списках одновременно. Результат выведите на
# # экран в виде строки чисел, записанных по возрастанию через пробел, используя команду (здесь s - это множество,
# # содержащее уникальные числа):
# # print(*sorted(s))
# # P. S. О функции sorted мы еще будем говорить, а также об операторе *. Пока просто запомните такую возможность сортировки
# # и вывода произвольных коллекций на экран.
# setA = set(input().split())  # 8 11 12 15 -2
# setB = set(input().split())  # 4 11 10 15 -5 1 -2
# s = setA & setB
# print(*sorted(s))  # -2 11 15

# # ______  Задание 195  ______
# #  На вход программе подаются два списка целых чисел, каждый с новой строки (в строке наборы чисел следующих через
# #  пробел). Необходимо прочитать эти наборы чисел и сохранить их в отдельных списках (или кортежах). Затем, с помощью
# #  множеств(а) выбрать уникальные числа, присутствующие в первом списке, но отсутствующие во втором. Результат выведите
# #  на экран в виде строки чисел, записанных по возрастанию через пробел, используя команду (здесь s - это множество,
# #  содержащее уникальные числа):
# # print(*sorted(s))
# setA = set(map(int, input().split()))  # 8 5 3 5 -3 1
# setB = set(map(int, input().split()))  # 1 2 3 4
# s = setA - setB
# print(*sorted(s))  # -3 5 8

# # ______  Задание 196  ______
# #  На вход программе подаются два списка целых чисел, каждый с новой строки (в строке наборы чисел следующих через пробел).
# #  Необходимо прочитать эти наборы чисел и сохранить их в отдельных списках (или кортежах). Затем, с помощью множеств(а)
# #  выбрать уникальные числа, присутствующие в первом или втором списках, но отсутствующие одновременно в обоих. Результат
# #  выведите на экран в виде строки чисел, записанных по возрастанию через пробел, используя команду (здесь s - это множество,
# #  содержащее уникальные числа):
# # print(*sorted(s))
# lstA = list(map(int, input().split()))  # 1 2 3 4 5
# lstB = list(map(int, input().split()))  # 4 5 6 7 8
# s = set(lstA) ^ set(lstB)
# print(*sorted(s))  # 1 2 3 6 7 8

# # ______  Задание 197  ______
# # На вход программе подаются две строки со списком городов, каждый с новой строки (в строках названия городов следуют
# # через пробел). Необходимо прочитать эти строки и сохранить их в отдельных списках (или кортежах). Затем, с помощью
# # множеств(а) сравнить их между собой на равенство по уникальным (не повторяющимся) городам. Если списки содержат одни
# # и те же уникальные города (не важно в каком порядке), то вывести на экран "ДА", иначе "НЕТ".
# cities1 = input().split()  # Москва Тверь Уфа Казань Уфа Москва
# cities2 = input().split()  # Уфа Тверь Москва Казань
# s = set(cities1) == set(cities2)
# if s:
#     print('ДА')
# else:
#     print('НЕТ')

# # ______  Задание 198  ______
# # На вход программе подаются оценки студента (его ответов у доски по предмету "Информатика") в виде чисел от 2 до 5,
# # записанных в одну строчку через пробел. Необходимо прочитать эти числа. Затем, проверить, если студент имеет хотя бы
# # одну двойку, то он не допускается до экзамена. Вывести на экран слово "ДОПУЩЕН", если студент не имеет ни одной двойки,
# # иначе вывести "НЕ ДОПУЩЕН". При реализации задачи используйте множество для определения наличия двойки.
# setA = set(map(int, input().split()))  # 3 4 4 5 2 3
# if 2 in setA:
#     print('НЕ ДОПУЩЕН')
# else:
#     print('ДОПУЩЕН')

# # ______  Задание 199  ______
# # На вход программе подаются две строки со списком городов, которые объехал Сергей в 1-й и 2-й годы своего путешествия
# # по России. Необходимо прочитать эти наборы строк и сохранить их в отдельных списках (или кортежах). Затем, требуется
# # определить, включал ли его маршрут во 2-й год все города 1-го года путешествия? Если это так, то вывести "ДА",
# # иначе "НЕТ".
# cities1 = input().split()  # Москва Казань Самара Москва
# cities2 = input().split()  # Москва Владимир Новгород Казань Самара Москва
# if set(cities2) >= set(cities1):
#     print('ДА')
# else:
#     print('НЕТ')
# # ДА

# # ______  Задание 200  ______
# # На вход программе подается натуральное число, которое может содержать только простые множители 1, 2, 3, 5 и 7 (любые
# # из них, не обязательно все). Необходимо прочитать это число и разложить его на простые множители. Затем, проверить,
# # содержит ли оно множители 2, 3 и 5 (обязательно все их, хотя бы один раз). Если это так, то вывести "ДА", иначе "НЕТ".
# n = int(input())  # 210
# multy_numbers = [1, 2, 3, 5, 7]
# lst = []
# for i in multy_numbers:
#     if n % i == 0:
#         lst.append(i)
# if set(lst) > set([2, 3, 5]):
#     print('ДА')
# else:
#     print('НЕТ')
# # ДА

# # ______  Задание 201  ______
# # На вход программе подается строка со списком оценок, например:
# # 2 неудовлетворительно удовлетворительно хорошо отлично
# # Первая цифра - это числовое значение первой оценки. Остальные оценки имеют возрастающие числа на 1.
# # Необходимо прочитать эту строку и с помощью генератора словарей сформировать словарь d, в котором ключами будут
# # выступать числа, а значениями - слова.
# # Например:
# # d = {2: 'неудовлетворительно', 3: 'удовлетворительно', 4: 'хорошо', 5: 'отлично'}
# # Вывести на экран значение сформированного словаря с ключом 4 (полагается, что такой ключ всегда существует).
# lst_in = input().split()
#
# d = {int(lst_in[0]) + i : lst_in[i + 1] for i in range(len(lst_in) - 1)}
# print(d[4])

# # ______  Задание 202  ______
# # На автомойку в течение квартала заезжали машины. Их гос. номера фиксировались в журнале, следующим образом (пример):
# # Е220СК
# # А120МВ
# # В101АА
# # Е220СК
# # А120МВ
# # В программе уже реализовано чтение этих строк и сохранение в списке:
# # lst_in = list(map(str.strip, sys.stdin.readlines()))
# # На основе этого списка через генератор множеств сформировать еще один список уникальных машин. На экран вывести
# # число уникальных машин.
# import sys
#
# # считывание списка из входного потока
# lst_in = list(map(str.strip, sys.stdin.readlines()))
#
# # здесь продолжайте программу (используйте список lst_in)
# d = {i for i in lst_in}
# print(len(d))

# # ______  Задание 203  ______
# # На вход программе подается строка со словами, записанными через пробел. Необходимо прочитать эту строку и с помощью
# # генератора множеств сформировать множество из уникальных слов без учета регистра и длина которых не менее трех символов.
# # Вывести на экран размер этого множества.
# set_in = {i.lower() for i in input().split() if len(i) >= 3}
# print(len(set_in))

# # ______  Задание 204  ______
# # На вход программе подается строка со словами, записанными через пробел. Необходимо прочитать эту строку и с помощью
# # генераторов множеств и словарей сформировать словарь в формате:
# # {слово_1: количество_1, слово_2: количество_2, ..., слово_N: количество_N}
# # То есть, ключами выступают уникальные слова (без учета регистра), а значениями - число их встречаемости в тексте.
# # На экран вывести значение словаря для слова (союза) 'и'. Если такого ключа нет, то вывести 0.
# lst_in = [i.lower() for i in input().split()]
# d = {i: lst_in.count(i) for i in lst_in}
#
# if 'и' in d:
#     print(d['и'])
# else:
#     print(0)

# # ______  Задание 205  ______
# # На вход программе подаются строки с информацией по книгам некоторого книжного магазина в формате:
# # <автор 1>: <название 1>
# # ...
# # <автор N>: <название N>
# # Авторы с названиями могут повторяться. Также в программе уже реализовано чтение этих строк и сохранение в списке:
# # lst_in = list(map(str.strip, sys.stdin.readlines()))
# # Необходимо, используя генераторы, сформировать словарь с именем d вида:
# # {'автор 1': {'название 1', 'название 2', ..., 'название M'}, ..., 'автор K': {'название 1', 'название 2', ..., 'название S'}}
# # То есть, ключами выступают уникальные авторы, а значениями - множества с уникальными названиями книг соответствующего автора.
# # На экран ничего выводить не нужно, только сформировать словарь обязательно с именем d - он, далее будет проверяться в тестах!
# lst_in = ['Пушкин: Сказка о рыбаке и рыбке', 'Есенин: Письмо к женщине', 'Тургенев: Муму', 'Пушкин: Евгений Онегин', 'Есенин: Русь']
# d = {}
# s = set()
# lst1 = [i.split(': ') for i in lst_in]
# for i in lst1:
#
#     if i[0] not in d:
#         d[i[0]] = {i[1]}
#     else:
#         d[i[0]] |= {i[1]}

# # ______  Задание 206  ______
# # Объявите в программе функцию, которая не имеет параметров и просто выводит на экран следующую строку:
# # It's my first function
# # После объявления вызовите эту функцию.
# def show():
#     print("It's my first function")
#
#
# show()

# # ______  Задание 207  ______
# # Объявите в программе функцию без параметров, которая читает из входного потока (с клавиатуры) имя и фамилию,
# # записанные в одну строку через пробел, и выводит на экран сообщение (без кавычек):
# # "Уважаемый, <имя> <фамилия>! Вы верно выполнили это задание!"
# # После объявления вызовите эту функцию.
# name, surname = input().split()
# def show(name, surname):
#     print(f"Уважаемый, {name} {surname}! Вы верно выполнили это задание!")
#
#
# show(name, surname)

# # ______  Задание 208  ______
# # Объявите в программе функцию, которая имеет один параметр - вес предмета, и выводит на экран сообщение (без кавычек):
# # "Предмет имеет вес: x кг."
# # где x - переданное значение (аргумент) функции. После объявления функции прочитайте (с помощью функции input)
# # вещественное число и вызовите функцию с этим числовым значением.
# def show(weight):
#     print(f"Предмет имеет вес: {weight} кг.")
#
#
# number = float(input())
# show(number)

# # ______  Задание 209  ______
# # Объявите в программе функцию, которая в качестве параметра принимает список (list), находит максимальное,
# # минимальное и сумму значений этого списка и выводит результат на экран в виде строки (без кавычек):
# # "Min = v_min, max = v_max, sum = v_sum"
# # где v_min, v_max, v_sum - вычисленные значения минимального, максимального и суммы значений списка.
# # После объявления функции прочитайте (с помощью функции input) список целых чисел, записанных в одну строку через
# # пробел, и вызовите функцию с передачей ей этого списка.
# def calculated(lst):
#     v_min = min(lst)
#     v_max = max(lst)
#     v_sum = sum(lst)
#
#     print(f"Min = {v_min}, max = {v_max}, sum = {v_sum}")
#
#
# lst = list(map(int, input().split()))
# calculated(lst)

# # ______  Задание 210  ______
# # Объявите в программе функцию с двумя параметрами width и height (ширина и высота прямоугольника), которая выводит
# # сообщение (без кавычек):
# # "Периметр прямоугольника, равен x"
# # где x - вычисленный периметр прямоугольника. После объявления функции прочитайте (с помощью функции input) два целых
# # числа, записанных в одну строку через пробел, и вызовите функцию с этими числовыми значениями.
# def calculate(width, height):
#     x = 2 * (width + height)
#     print(f"Периметр прямоугольника, равен {x}")
#
#
# n1, n2 = map(int, input().split())
#
# calculate(n1, n2)

# # ______  Задание 211  ______
# # бъявите в программе функцию с одним параметром, которая проверяет корректность переданного ей email-адреса в виде
# # строки. Полагается, что адрес верен, если он обязательно содержит символы '@' и '.', а все остальные символы могут
# # принимать значения: 'a-z', 'A-Z', '0-9' и '_'. Если email верен, то функция выводит "ДА", иначе "НЕТ".
# # После объявления функции прочитайте (с помощью функции input) строку с email-адресом и вызовите функцию с этим аргументом.
# def check(mail):
#     if '@' in mail and '.' in mail:
#         for i in mail:
#             if i.lower() in simbols or i in ['_', '@', '.'] or i.isdigit():
#                 counter.append('+')
#             else:
#                 counter.append('-')
#
#     else:
#         counter.append('-')
#
#     if '-' in counter:
#         print('НЕТ')
#     else:
#         print('ДА')
#
#
# simbols = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
#            'w', 'x', 'y', 'z']
# counter = []
# mail = input()
# check(mail)

# # решение другого ученика
# def check_mail(mail):
#     allow = set("abcdefghijklmnopqrstuvwxyz0123456789_@.")
#     nesessary = {"@", "."}
#     print("ДА") if nesessary <= mail <= allow else print("НЕТ")
#
#
# msg = set(input().lower())
# check_mail(msg)

# # # решение другого ученика
# def check_email(email):
#     print(
#         'ДА' if '@' in email and
#         '.' in email and
#         sum([0 if i == '@' or i == '.' or 'a' <= i <= 'z' or 'A' <= i <= 'Z' or '0' <= i <= '9' or i == '_' else 1 for i in email]) == 0
#         else 'НЕТ'
#     )
#
#
# check_email(input())

# # ______  Задание 212  ______
# # Объявите в программе функцию с именем get_sq, которая имеет один параметр (принимает вещественное число). В теле
# # функции значение параметра возводится в квадрат и возвращается функцией.
# # После объявления функции прочитайте (с помощью функции input) вещественное число из входного потока и вызовите функцию
# # с прочитанным значением. Выведите на экран число, которое возвратила функция.
# def get_sq(x):
#     return x ** 2
#
#
# n = float(input())
# print(get_sq(n))

# # ______  Задание 213  ______
# # Объявите функцию с именем is_triangle, которая принимает три стороны треугольника (целые числа) и проверяет, можно ли
# # из переданных аргументов составить треугольник. (Напомню, что у любого треугольника длина любой его стороны должна
# # быть меньше суммы двух других). Если  проверка проходит, функция должна возвращать булево значение True, а иначе False.
# # Вызывать функцию не нужно, только объявить.
# def is_triangle(a, b, c):
#     return a < (b + c) and b < (a + c) and c < (a + b)

# # ______  Задание 214  ______
# #  Объявите функцию с именем is_large, которая принимает строку (в качестве параметра) и возвращает булево значение
# # False, если длина строки меньше трех символов, иначе True.
# # Вызывать функцию не нужно, только объявить.
# def is_large(my_str):
#     return False if len(my_str) < 3 else True

# # ______  Задание 215  ______
# # Объявите в программе функцию с одним параметром для проверки переданного числа на четность. Функция должна возвращать
# # булево значение True, если переданное число четное и False, в противном случае.
# # После объявления функции в цикле на каждой итерации необходимо читать целочисленное числовое значение командой:
# # x = int(input())
# # Цикл должен работать пока x не равен 1. Если прочитанное значение x четное (проверяется с помощью ранее объявленной
# # функции), то число выводится на экран (каждое с новой строки).
# def num(x):
#     return x % 2 == 0
#
#
# x = 0
# while x != 1:
#     x = int(input())
#     if num(x):
#         print(x)

# # ______  Задание 216  ______
# # Объявите в программе функцию с одним параметром для проверки переданного числа на нечетность. Функция должна возвращать
# # булево значение True, если переданное число нечетное, и False в противном случае.
# # После объявления функции далее в программе прочитайте последовательность целых чисел, подаваемых на вход программе,
# # с помощью команды:
# # lst_d = list(map(int, input().split()))
# # Затем, используя генератор списков и объявленную ранее функцию, сформируйте список lst из нечетных значений на основе
# # списка lst_d. Результат отобразите на экране командой:
# # print(*lst)
# def num(x):
#     return x % 2 != 0
#
#
# lst_d = list(map(int, input().split()))
# lst = [x for x in lst_d if num(x)]
#
# print(*lst)

# # ______  Задание 217  ______
# # На вход программе подается строка (слово), которое читается в переменную tp с помощью команды:
# # tp = input().strip()
# # Если переменная tp равна строке "RECT", то следует объявить функцию с именем get_sq с двумя параметрами (длина и ширина
# # прямоугольника), вычисляющую площадь прямоугольника по переданным аргументам и возвращающую вычисленное значение.
# # (Функция на экран ничего выводить не должна).
# # Если переменная tp не равна строке "RECT", то следует объявить функцию с тем же именем get_sq, но с одним параметром
# # (длина стороны квадрата) для вычисления площади квадрата (формула: a*a). Вычисленное значение возвращается функцией.
# # (Функция на экран ничего выводить не должна).
# # Примечание: в программе должна быть задана только одна функция с именем get_sq в зависимости от введенного слова
# # (значения переменной tp). Вызывать функцию не нужно, только объявить.
# tp = input().strip()
# if tp == 'RECT':
#     def get_sq(length, width):
#         return length * width
# else:
#     def get_sq(width):
#         return width * width

# # ______  Задание 218  ______
# # Объявите в программе функцию, которая имеет один параметр, принимающий строку. Функция должна возвращать булево значение
# # False, если длина переданной строки меньше 6 символов, иначе возвращать булево значение True.
# # После объявления функции далее в программе прочитайте из входного потока строку с названиями городов, записанных через
# # пробел. Сформируйте на основе прочитанной строки список cities из названий городов. Затем, используя генератор списка
# # и ранее объявленную функцию, сформируйте новый список lst из названий городов с длинами не менее шести символов
# # (города выбираются из списка cities). Результат отобразите на экране командой:
# # print(*lst)
# def len_str(my_str):
#     return False if len(my_str) < 6 else True
#
#
# cities = input().split()
# lst = [city for city in cities if len_str(city)]
# print(*lst)

# # ______  Задание 219  ______
# #  Объявите функцию, которая имеет один параметр, принимающий строку. Функция должна возвращать два значения в виде кортежа:
# #  переданную строку и ее длину.
# # После объявления функции далее в программе прочитайте из входного потока строку с названиями городов, записанных через
# # пробел. Сформируйте на основе прочитанной строки список cities из названий городов. Затем, используя генератор словарей
# # и ранее объявленную функцию, сформируйте на основе списка cities словарь d в формате:
# # d = {<город 1>: <число символов>, ..., <город N>: <число символов>}
# # Выведите этот словарь в порядке возрастания длин строк с помощью команд:
# # a = sorted(d, key=d.get)
# # print(*a)
# def len_str(my_str):
#     return my_str, len(my_str)
#
# cities = input().split()
# d = dict(len_str(city) for city in cities)
# a = sorted(d, key=d.get)
# print(*a)

# # ______  Задание 220  ______
# #  На вход программе подаются целые числа, записанные в одну строчку через пробел. Необходимо их прочитать и сохранить
# #  в списке digs. Затем (или в самом начале программы), объявить функцию, которая имеет два параметра (будут передаваться
# #  максимальное и минимальное значения из сформированного списка digs) и возвращающую произведение двух переданных аргументов.
# # Вызовите эту функцию с передачей ей в качестве аргументов минимального и максимального числового значения из списка digs.
# # Отобразите на экране значение, возвращенное функцией.
# # Подсказка: для передачи аргументов функции используйте стандартные функции max и min языка Python.
# def min_max(n_min, n_max):
#     return n_min * n_max
#
#
# digs = list(map(int, input().split()))
# print(min_max(min(digs), max(digs)))

# # ______  Задание 221  ______
# # Повторите быстрый алгоритм Евклида для нахождения наибольшего общего делителя двух натуральных чисел a и b. В программе
# # необходимо объявить функцию get_nod с двумя параметрами a и b (натуральные числа) и возвращающую значение НОД(a, b).
# # P. S. Вызывать функцию не нужно, только задать. Постарайтесь реализовать алгоритм, не возвращаясь к материалу на видео.
# def get_nod(a, b):
#     if a < b:
#         a, b = b, a
#
#     while b != 0:
#         a, b = b, a % b
#
#     return a

# # ______  Задание 222  ______
# # Объявите в программе функцию с именем get_rect_value, которая первыми двумя параметрами принимает длину и ширину
# # прямоугольника (числа), а третий формальный параметр tp имеет начальное значение 0. Если параметр tp равен нулю,
# # то функция должна возвращать периметр прямоугольника, вычисленного на основе первых двух переданных аргументов, а иначе его площадь.
# # P. S. Вызывать функцию не нужно, только объявить.
# def get_rect_value(a, b, tp=0):
#     if tp == 0:
#         return 2 * (a + b)
#     else:
#         return a * b

# # ______  Задание 223  ______
# # Объявите в программе функцию с именем check_password, которая первым параметром принимает строку (пароль) и имеет
# # второй формальный параметр chars с начальным значением в виде строки "$%!?@#". Функция должна проверять, есть ли в
# # пароле хотя бы один символ из chars и что длина пароля не менее 8 символов. Если проверка проходит, то функция
# # возвращает булево True, иначе False.
# # P. S. Вызывать функцию не нужно, только объявить.
# def check_password(psw, chars='$%!?@#'):
#     if len(psw) >= 8 and set(psw) & set(chars):
#         return True
#     else:
#         return False

# # ______  Задание 224  ______
# # Объявите в программе функцию, которая первым параметром принимает строку (с кириллицей и латиницей) и преобразовывает
# # в ней кириллические символы в латиницу, используя следующий словарь для замены русских букв на соответствующее латинское
# # написание:
# # t = {'ё': 'yo', 'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ж': 'zh',
# #      'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm', 'н': 'n', 'о': 'o', 'п': 'p',
# #      'р': 'r', 'с': 's', 'т': 't', 'у': 'u', 'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch', 'ш': 'sh',
# #      'щ': 'shch', 'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya'}
# # Функция должна возвращать результат преобразования переданной строки в латиницу. Замены делать без учета регистра
# # (исходную строку вначале следует перевести в нижний регистр - малые буквы).
# # Второй формальный параметр функции с именем sep и начальным значением в виде строки "-". Он определяет символ для
# # замены пробелов в строке.
# # На вход программе подается строка, которую необходимо прочитать (после объявления функции). Затем, дважды вызовите
# # функцию (с выводом результата ее работы на экран):
# # первый раз только с прочитанной строкой;
# # второй раз с прочитанной строкой и именованным аргументом sep со значением '+'.
# t = {'ё': 'yo', 'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ж': 'zh',
#      'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm', 'н': 'n', 'о': 'o', 'п': 'p',
#      'р': 'r', 'с': 's', 'т': 't', 'у': 'u', 'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch', 'ш': 'sh',
#      'щ': 'shch', 'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya'}
# def repl(my_str, sep='-'):
#     my_str = my_str.lower()
#     t[' '] = sep
#     lst = [t[i] if i in t else i for i in my_str]
#     lst = ''.join(lst)
#     return lst
#
# str_in = input()
# print(repl(str_in))
# print(repl(str_in, sep='+'))

# # решение другого ученика
# t = {'ё': 'yo', 'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ж': 'zh',
#      'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm', 'н': 'n', 'о': 'o', 'п': 'p',
#     'р': 'r', 'с': 's', 'т': 't', 'у': 'u', 'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch', 'ш': 'sh',
#     'щ': 'shch', 'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya'}
#
#
# def transliterate(text, sep='-'):
#     return ''.join(t.get(i, i) for i in text.lower()).replace(' ', sep)
#
#
# s = input()
# print(transliterate(s))
# print(transliterate(s, sep='+'))

# # ______  Задание 225  ______
# #  Объявите в программе функцию, которая первым параметром принимает строку, а второй формальный параметр tag  с начальным
# #  значением в виде строки "h1" определяет тег, в который должна заключаться первая переданная строка. Например, мы передаем
# #  строку "Hello Python" и заключаем в тег "h1". Функция должна вернуть строку (без кавычек):
# # "<h1>Hello Python</h1>"
# # То есть, сначала открывается тег <h1>, а в конце строки - закрывается </h1>. И так для любых указанных тегов.
# # После объявления функции далее в программе прочитайте из входного потока строку и дважды вызовите функцию (с выводом
# # результата ее работы на экран):
# # первый раз только со строкой;
# # второй раз со строкой и именованным аргументом tag со значением 'div'.
# def dif_str(str_in, div='h1'):
#
#     return f'<{div}>{str_in}</{div}>'
#
# str_in = input()
#
# print(dif_str(str_in))
# print(dif_str(str_in, 'div'))

# # другое решение ученика
# def tagged_st(st, tag='<h1>'):
#     return tag + st + tag.replace('<', '</')
#
#
# st = input()
# print(tagged_st(st))
# print(tagged_st(st, tag='<div>'))

# # ______  Задание 226  ______
# # В функцию из предыдущего подвига 5 добавьте в конец еще один третий формальный параметр up с начальным булевым
# # значением True. Если параметр up равен True, то тег, указанный в формальном параметре tag, следует записывать заглавными
# # буквами, а иначе малыми.
# # После объявления функции далее в программе прочитайте из входного потока строку и дважды вызовите функцию (с выводом
# # результата ее работы на экран):
# # первый раз со строкой и именованным аргументом tag со значением 'div';
# # второй раз со строкой, именованным аргументом tag со значением 'div' и именованным аргументом up со значением False.
# def dif_str(str_in, div='h1', up=True):
#     if up:
#         new_str = f'<{div.upper()}>{str_in}</{div.upper()}>'
#     else:
#         new_str = f'<{div.lower()}>{str_in}</{div.lower()}>'
#
#     return new_str
#
# str_in = input()
#
# print(dif_str(str_in, 'div'))
# print(dif_str(str_in, 'div', False))

# решение другого ученика
# def enclosure(html, tag='h1', up=True):
#     return '<{1}>{0}</{1}>'.format(html, tag.upper() if up == True else tag)
#
# html = input()
# print(enclosure(html, tag='div'))
# print(enclosure(html, tag='div', up=False))

# # решение другого ученика
# def set_tag(st, tag='h1', up=True):
#     return (f'<{tag.upper()}>{st}</{tag.upper()}>'
#             if up else
#             f'<{tag}>{st}</{tag}>')
#
# st = input()
# print(set_tag(st, tag='div'))
# print(set_tag(st, tag='div', up=False))

# # ______  Задание 227  ______
# # Объявите в программе функцию с именем get_even, которая способна принимать произвольное количество чисел в качестве
# # аргументов. Например: get_even(1, 2, 3, -5, 10, 8) Функция должна возвращать список, составленный только из четных
# # переданных ей значений. P.S. Функцию вызывать не нужно, только определить.
# def get_even(*args):
#     lst = [i for i in args if i % 2 == 0]
#
#     return lst

# # ______  Задание 228  ______
# # Объявите в программе функцию с именем get_biggest_city, которой можно передавать произвольное количество названий
# # городов (строк) через аргументы. Например:
# # get_biggest_city('Город 1', 'Город 2', 'Город 3', 'Город 4')
# # Данная функция должна возвращать название города (строку) наибольшей длины. Если таких городов несколько, то первый
# # переданный (из наибольших). Программу реализовать без использования сортировки.
# # P.S. Функцию выполнять не нужно, только определить.
# def get_biggest_city(*args):
#     key = {}
#
#     for i in args:
#         if len(i) not in key:
#             key[len(i)] = i
#
#     return key[max(key)]

# # ______  Задание 229  ______
# # Объявите в программе функцию с именем get_data_fig для вычисления периметра произвольного N-угольника. На вход этой
# # функции передаются N длин сторон через ее аргументы. Дополнительно могут быть указаны именованные аргументы:
# # tp - булево значение True/False;
# # color - целое числовое значение;
# # closed - булево значение True/False;
# # width - вещественное значение.
# # Функция должна возвращать в виде кортежа периметр многоугольника и указанные значения именованных параметров в порядке
# # их перечисления в тексте задания (если они были переданы). Если какой-либо параметр отсутствует, его возвращать не нужно
# # (пропустить).
# # P.S. Функцию выполнять не нужно, только объявить.
# def get_data_fig(*args, **kwars):
#     counter = 0
#     for i in args:
#         counter += i
#     lst  = [i for i in kwars]
#     tpl = ()
#     for i in ('tp', 'color', 'closed', 'width'):
#         if i in lst:
#             tpl += (kwars[i],)
#     tpl2 = (counter,) + tpl
#
#     return tpl2

# # решение другого ученика
# def get_data_fig(*args, **kwargs):
#     kwargs = [kwargs[i] for i in ['type', 'color', 'closed', 'width'] if i in kwargs]
#     return (sum(args), *kwargs)

# # решение другого ученика
# def get_data_fig(*n, type=None, color=None, closed=None, width=None):
#     res = (sum(n),) + tuple(key for key in [type, color, closed, width] if key != None)
#     return res

# # ______  Задание 230  ______
# # (Для закрепления предыдущего материала). На вход программе подается таблица целых чисел (см. пример ниже) размером
# # N x N элементов (N определяется по входным данным). Необходимо прочитать эти числа и сохранить в виде двумерного
# # (вложенного) списка lst2D размером N x N элементов. Полученная таблица будет содержать нули и кое-где единицы. С помощью
# # функции с именем verify, на вход которой подается двумерный список чисел (первый параметр), необходимо проверить,
# # являются ли единицы изолированными друг от друга, то есть, вокруг каждой единицы должны быть нули.
# # Рекомендуется следующий алгоритм. В функции verify производить перебор двумерного списка. Для каждого элемента (списка)
# # со значением 1 вызывать еще одну вспомогательную функцию is_isolate для проверки изолированности единицы. То есть,
# # функция is_isolate должна возвращать True, если единица изолирована и False в противном случае.
# # Как только встречается не изолированная единица, функция verify должна возвращать False. Если успешно доходим (по
# # элементам списка) до конца, то возвращается значение True
# # Функцию verify выполнять не нужно, только объявить.
# # P. S. При реализации функции is_isolate не следует прописывать восемь операторов if. Подумайте, как это можно сделать
# # красивее (с точки зрения реализации алгоритма).
#
# def is_isolate(*args):
#     lst2D, i, j = args
#     return lst2D[i][j] + lst2D[i][j + 1] + lst2D[i + 1][j] + lst2D[i + 1][j + 1] > 1
#
# def verify(lst2D):
#
#     flag = True
#     for i in range(len(lst2D) - 1):
#         if flag:
#             for j in range(len(lst2D) - 1):
#                 if is_isolate(lst2D, i, j):
#                     flag = False
#                     return False
#
#         else:
#             break
#     if flag:
#         return True
#
# # lines =  ['1 0 0 0 0\n', '0 0 1 0 0\n', '0 0 0 0 0\n', '0 1 0 1 0\n', '0 0 0 0 0\n']
# # lines =  ['1 0 0 0 0 0\n', '0 0 1 0 0 1\n', '0 0 1 0 0 1\n', '0 1 0 1 0 0\n', '0 0 0 0 0 1\n', '0 0 0 0 0 0\n']
# lst2D = [[int(j) for j in i.replace('\n','').split(' ')] for i in lines]
# # print(lst2D)
#
# # print(verify(lst2D))

# # ______  Задание 231  ______
# # (Для закрепления предыдущего материала). Объявите в программе функцию с именем str_min, которая сравнивает две
# # переданные строки (через два первых параметра) и возвращает минимальную из них (то есть, выполняется лексикографическое
# # сравнение строк). Следом объявите еще две аналогичные функции:
# # с именем str_min3 для поиска минимальной строки из трех переданных строк;
# # с именем str_min4 для поиска минимальной строки из четырех переданных строк.
# # Причем при реализации функций str_min3 и str_min4 следует использовать вызов (результат работы) функции str_min.
# # P.S. Выполнять функции не нужно, только объявить.
# def str_min(str1, str2):
#     return min(str1, str2)
#
# def str_min3(str1, str2, str3):
#     return min(str1, str_min(str2, str3))
#
# def str_min4(str1, str2, str3, str4):
#     return min(str1, str_min(str4, str_min(str2, str3)))

# # ______  Задание 232  ______
# # На вход программе подаются семь целых чисел, записанных в одну строчку через пробел. Необходимо их прочитать и первые
# # четыре числа занести в переменную (список) lst, а остальные три в отдельные переменные x, y, z. Сделать это нужно с
# # использованием оператора упаковки. Вывести список lst на экран с помощью команды:
# # print(*lst)
# *lst, x, y, z = list(map(int, input().split()))
# print(*lst)

# # ______  Задание 233  ______
# # На вход программе подается строка с названиями городов, записанных в одну строчку через пробел. Необходимо прочитать
# # эту строку и на ее основе сформировать список из названий городов. Затем, используя оператор распаковки *, преобразовать
# # этот список в кортеж lst_c. Результат вывести на экран командой:
# # print(lst_c)
# lst_c = (*list(input().split()),)
# print(lst_c)

# # ______  Задание 234  ______
# # На вход программе подаются два целых числа a и b (a < b), записанные в одну строчку через пробел. Необходимо их прочитать
# # и сформировать список lst из целых чисел в диапазоне от a до b (включительно) с шагом 1, используя функцию range,
# # оператор [] и оператор распаковки *. Вывести полученный список на экран командой:
# # print(*lst)
# a, b = [*map(int, input().split())]
# lst = [*range(a, b + 1)]
# print(*lst)

# # решение другого ученика
# lst = list(map(int, input().split()))
# lst[-1] += 1
# print(*range(*lst))

# # решение другого ученика
# a = *(map(int, input().split())),
# print(*range(a[0], a[-1] + 1))

# # ______  Задание 235  ______
# #  На вход программе подаются вещественные числа и следующей строкой названия городов, записанные через пробел.
# #  Необходимо прочитать числа, сохранить их в виде списка. Затем, прочитать строку с названиями городов и сформировать
# #  на ее основе еще один список. После этого сформировать единый список lst, в котором сначала идут числа, а затем, названия городов.
# # Объединение списков реализовать с использованием оператора распаковки *. Вывести полученный список lst на экран командой:
# # print(*lst)
# lst1 = [*map(float, input().split())]
# lst2 = input().split()
# lst = [*lst1, *lst2]
# print(*lst)

# # ______  Задание 236  ______
# # Объявите в программе словарь, содержащий следующие пункты меню:
# # menu = {'Главная': 'home', 'Архив': 'archive', 'Новости': 'news'}
# # Дополнительно на вход программе подаются еще пункты меню в виде строк в формате:
# # название_1=url_1
# # ...
# # название_N=url_N
# # В программе уже реализовано их считывание и сохранение в списке:
# # lst_in = list(map(str.strip, sys.stdin.readlines()))
# # Необходимо информацию из списка lst_in преобразовать в словарь того же формата, что и menu, и добавить в конец словаря menu,
# # используя оператор распаковки для словарей. На результирующий словарь должна вести переменная menu.
# # P.S. В программе ничего выводить на экран не нужно! Только сформировать словарь menu.
# menu = {'Главная': 'home', 'Архив': 'archive', 'Новости': 'news'}
# # lst_in = ['Города=about-cities', 'Машины=read-of-cars', 'Самолеты=airplanes']
# a = {}
# for i in lst_in:
#     i, j = i.split('=')
#     a[i] = j
# menu = {**a, **menu}

# # ______  Задание 237  ______
# # На вход программе подается целое положительное число N. Необходимо написать рекурсивную функцию с именем get_rec_N,
# # которая отображает на экране последовательность целых чисел от 1 до N (включительно). Каждое число выводится с новой строки.
# # В качестве единственного параметра функция get_rec_N должна принимать числовое значение. Начальный вызов функции уже
# # дан в программе и выглядит так:
# # get_rec_N(N)
# N = int(input())
#
# def get_rec_N(n):
#     if n != 1:
#         get_rec_N(n - 1)
#     print(n)
#
# get_rec_N(N)

# # ______  Задание 238  ______
# #  На вход программе подаются целые числа, записанные через пробел. Необходимо их прочитать и сохранить в виде списка
# #  (или кортежа). Затем, объявить рекурсивную функцию с именем get_rec_sum для вычисления суммы прочитанных чисел.
# #  То есть, функция get_rec_sum в итоге должна возвращать значение суммы. (Выводить на экран она ничего не должна).
# #  Первым параметром в функцию следует передавать список чисел. Остальные параметры продумайте самостоятельно.
# # Вызовите функцию get_rec_sum и выведите на экран значение суммы, которое она вернула.
# def get_rec_sum(lst):
#     n, *lst = lst
#     if len(lst) == 1:
#         return n + lst[0]
#     else:
#         return n + get_rec_sum(lst)
#
# lst = list(map(int, input().split()))
#
# print(get_rec_sum(lst))

# решение другого ученика
# lst1 = [int(i) for i in input().split()]
#
# def get_rec_sum(lst):
#     head, *tail = lst
#     return head + get_rec_sum(tail) if tail else head
#
# print(get_rec_sum(lst1))

# # ______  Задание 239  ______
# # На вход программе подается натуральное число N (N >= 2), которое читается с помощью команды:
# # N = int(input())
# # Необходимо с помощью рекурсивной функции сигнатуры:
# # def fib_rec(N, f=[1, 1]): ...
# # (здесь N - общее количество чисел Фибоначчи; f - начальный список этих чисел) сформировать последовательность чисел
# # Фибоначчи по правилу: первые два числа равны 1 и 1, а каждое следующе значение равно сумме двух предыдущих. Пример
# # такой последовательности для первых 7 чисел: 1, 1, 2, 3, 5, 8, 13, ...
# # Функция должна возвращать список сформированной последовательности длиной N. Вызывать функцию не нужно, только объявить.
# N = int(input())
#
# def fib_rec(N, f=[1, 1]):
#     if N == 1:
#         return [1]
#     N -= 1
#     if N > 1:
#         f += [f[-1] + f[-2]]
#         fib_rec(N, f)
#     return f

# решение другого ученика
# # ввод числа N
# N = int(input())
#
# # здесь задается функция fib_rec (переменную N не менять!)
#
# def fib_rec(N, f=[]):
#     if len(f) < N:
#         f.append(1 if len(f) < 2 else f[-1] + f[-2])
#         fib_rec(N)
#
#         return f
#

# решение другого ученика
# # ввод числа N
# N = int(input())
#
# def fib_rec(N, f=[1, 1]):
#     if N > 2:
#         f.append(f[-1] + f[-2])
#         fib_rec(N - 1, f)
#     return f

# решение другого ученика
# N = int(input())
#
# def fib_rec(N, f=[1, 1]):
#     return fib_rec(N, f + [f[-2] + f[-1]]) if len(f) < N else f[:N]

# # ______  Задание 240  ______
# # На вход программе подается целое неотрицательное число n, которое читается командой:
# # n = int(input())
# # Необходимо объявить рекурсивную функцию fact_rec со следующей сигнатурой:
# # def fact_rec(n): ...
# # для вычисления факториала числа n. Напомню, что факториал числа, равен:
# # Функция должна возвращать вычисленное значение. Вызывать функцию не нужно, только объявить.
# n = int(input())
# def fact_rec(n):
#     if n == 0:
#         return 1
#     else:
#         return fact_rec(n - 1) * n

# # ______  Задание 241  ______
# # В программе объявлен следующий многомерный список:
# # d = [1, 2, [True, False], ["Москва", "Уфа", [100, 101], ['True', [-2, -1]]], 7.89]
# # С помощью рекурсивной функции get_line_list необходимо на его основе создать одномерный список из значений
# # элементов списка d. Функция должна возвращать новый созданный одномерный список.  (Только возвращать, выводить на
# # экран ничего не нужно.)
# # Вызывать функцию не нужно, только объявить со следующей сигнатурой:
# # def get_line_list(d,a=[]): ...
# # где d - исходный список; a - новый формируемый.
# d = [1, 2, [True, False], ["Москва", "Уфа", [100, 101], ['True', [-2, -1]]], 7.89]
# def get_line_list(d,a=[]):
#     for i in d:
#         if type(i) == list:
#             get_line_list(i)
#
#         else:
#            a += [i]
#     return a
#
# # print(get_line_list(d))

# # решение другого ученика
# d = [1, 2, [True, False], ["Москва", "Уфа", [100, 101], ['True', [-2, -1]]], 7.89]
#
# def get_line_list(d, a=[]):
#     [get_line_list(f, a) if type(f) == list else a.append(f) for f in d]
#     return a

# # ______  Задание 242  ______
# # Лягушка прыгает вперед и может скакнуть либо на одно деление, либо сразу на два. Наша задача определить количество
# # вариантов маршрутов, которыми лягушка может достичь риски под номером N (натуральное число N подается на вход программе).
# # Решать задачу следует с применением рекурсивной функции. Назовем ее get_path. Алгоритм решения следующий. Рассмотрим,
# # например, риску под номером 4. Очевидно, в нее лягушка может скакнуть либо с риски номер 2, либо с риски номер 3.
# # Значит, общее число вариантов перемещений лягушки можно определить как:
# # get_path(4) = get_path(3) + get_path(2)
# # Аналогично будет справедливо и для любой риски N:
# # get_path(N) = get_path(N-1) + get_path(N-2)
# # А начальные условия задачи, следующие:
# # get_path(1) -> 1
# # get_path(2) -> 2
# # Реализуйте такую рекурсивную функцию, которая должна возвращать количество вариантов перемещений лягушки для риски под номером N.
# # Вызовите эту функцию для введенного числа N и отобразите результат на экране.
# def get_path(N):
#     if N == 2:
#         return 2
#     if N == 1:
#         return 1
#     else:
#         return get_path(N - 1) + get_path(N - 2)
#
#
# N = int(input())
#
# print(get_path(N))

# решение другого ученика
# N = int(input())
#
# def get_path(n):
#     return n if n in (1, 2) else get_path(n - 1) + get_path(n - 2)
#
# print(get_path(N))

# # ______  Задание 242  ______
# # На вход программе подаются целые числа, записанные через пробел. Необходимо их прочитать и сохранить в списке. Затем,
# # выполнить сортировку этого списка по возрастанию с помощью алгоритма сортировки слиянием. Функция должна возвращать
# # новый отсортированный список.
# # Вызовите результирующую функцию сортировки для введенного списка и отобразите результат на экран в виде последовательности
# # чисел, записанных через пробел.
# # Подсказка: для разбиения списка и его последующей сборки используйте рекурсивные функции.
# # P. S. Теория сортировки в видео предыдущего шага.
# lst = list(map(int, input().split()))
# def merge(lst1, lst2):
#     lst3 = []
#     N = len(lst1)
#     M = len(lst2)
#
#     i = 0
#     j = 0
#     while i < N and j < M:
#         if lst1[i] < lst2[j]:
#             lst3.append(lst1[i])
#             i += 1
#         else:
#             lst3.append(lst2[j])
#             j += 1
#
#     lst3 += lst1[i:] + lst2[j:]
#     return lst3
#
# def split_lst(lst):
#     D = len(lst) // 2
#     lst_a = lst[:D]
#     lst_b = lst[D:]
#
#     if len(lst_a) > 1:
#         lst_a = split_lst(lst_a)
#
#     if len(lst_b) > 1:
#         lst_b = split_lst(lst_b)
#
#     return merge(lst_a, lst_b)
#
# print(*split_lst(lst))

# # решение другого ученика, не соответствует условиям, но интересный вариант
# print(*sorted(map(int,input().split())))

# # ______  Задание 243  ______
# # Объявите анонимную (лямбда) функцию с одним параметром для возведения числа в квадрат. Присвойте эту функцию
# # переменной get_sq.
# # Вызывать функцию не нужно, только объявить.
# get_sq = lambda x: x ** 2

# # ______  Задание 244  ______
# # Объявите анонимную (лямбда) функцию с двумя параметрами для деления первого целого числа (первого параметра) на
# # второй (второй параметр). Если происходит деление на ноль, то функция должна возвращать значение None, иначе -
# # результат деления.
# # Присвойте эту функцию переменной get_div. Вызывать функцию не нужно, только задать.
# get_div = lambda x, y: x / y if y != 0 else None

# # ______  Задание 245  ______
# # Объявите анонимную (лямбда) функцию для вычисления модуля числа (то есть, отрицательные числа нужно делать
# # положительными). Вызовите эту функцию для числа x, которое следует прочитать из входного потока командой:
# # x = float(input())
# # Отобразите результат работы функции на экране.
# x = float(input())
# mod = lambda x: abs(x)
# print(mod(x))

# # ______  Задание 246  ______
# # Объявите анонимную (лямбда) функцию для определения вхождения в переданную ей строку фрагмента "ra". То есть,
# # функция должна возвращать True, если такой фрагмент присутствует в строке и False в противном случае.
# # Вызовите эту функцию для строки s, которую следует прочитать из входного потока командой:
# # s = input()
# # Отобразите результат работы функции на экране.
# s = input()
# def_in = lambda s: 'ra' in s.lower()
# print(def_in(s))

# # ______  Задание 247  ______
# # В программе задана функция filter_lst (см. программу ниже), которая отбирает элементы, переданного ей итерируемого
# # объекта и возвращает сформированный кортеж значений.
# # На вход программы поступает список целых чисел, записанных через пробел. Необходимо прочитать эти числа и сохранить
# # в списке digs. Затем, вызовите функцию filter_lst несколько раз для формирования:
# # кортежа из всех значений списка digs (передается в параметр it);
# # кортежа только из отрицательных чисел переданного списка digs;
# # кортежа только из неотрицательных чисел (то есть, включая и 0) переданного списка digs;
# # кортежа из чисел в диапазоне [3; 5] переданного списка digs.
# # Для отбора нужных значений формальному параметру key следует передавать соответствующие определения анонимной функции.
# # Каждый результат работы функции следует отображать с новой строки командой:
# # print(*lst)
# # где lst - кортеж, возвращенный функцией filter_lst.
# def filter_lst(it, key=None):
#     if key is None:
#         return tuple(it)
#
#     res = ()
#     for x in it:
#         if key(x):
#             res += (x,)
#
#     return res
#
#
# digs = list(map(int, input().split()))
#
# print(*filter_lst(digs))
# print(*filter_lst(digs, lambda i: i < 0))
# print(*filter_lst(digs, lambda i: i >= 0))
# print(*filter_lst(digs, lambda i: i in range(3, 6)))

# # ______  Задание 248  ______
# # Имеется программа (см. листинг ниже), где читается глобальная переменная WIDTH (из входного потока) и функция с именем
# # func1. Допишите в теле функции команду, которая бы позволяла изменять глобальную переменную WIDTH.
# WIDTH = int(input())
#
#
# def func1():
#     global WIDTH
#     WIDTH += 1
#     return WIDTH
#
#
# print(func1())

# # ______  Задание 249  ______
# #  Имеется программа (см. листинг ниже). Необходимо в теле функции func2 дописать команду, которая бы меняла значение
# #  уже существующей переменной msg, объявленной в функции func1.
# def func1():
#     msg = input()
#
#
#     def func2():
#         nonlocal msg
#         msg = input()
#         print(msg)
#
#
#     func2()
#     print(msg)
#
#
# func1()

# # ______  Задание 250  ______
# # Объявите функцию с именем create_global, которая имеет следующую сигнатуру:
# # def create_global(x): ...
# # Эта функция должна создавать глобальную переменную с именем TOTAL и присваивать ей значение x.
# # (Ничего выводить на экран она не должна, только создавать переменную).
# # Вызывать функцию не нужно, только определить.
# def create_global(x):
#     global TOTAL
#     TOTAL = x

# # ______  Задание 251  ______
# # Объявите внешнюю функцию с именем counter_add и следующей сигнатурой:
# # def counter_add(): ...
# # В функции counter_add объявите вложенную функцию с одним параметром. При этом внешняя функция counter_add должна
# # возвращать ссылку на вложенную функцию. Это и есть реализация замыкания.
# # Вложенная функция должна увеличивать значение переданного аргумента (через ее единственный параметр) на 5 и возвращать
# # вычисленный результат.
# # После этого вызовите в программе функцию counter_add и результат ее работы присвойте переменной с именем cnt. То есть,
# # переменная cnt будет ссылаться на вложенную функцию. Затем, вызовите внутреннюю функцию через переменную cnt со
# # значением k, которое следует прочитать из входного потока командой:
# # k = int(input())
# # Выведите результат работы вложенной функции на экран.
# def counter_add():
#     def add_inner(counter):
#         counter += 5
#         return counter
#
#     return add_inner
#
#
# k = int(input())
# cnt = counter_add()
# print(cnt(k))

# # ______  Задание 252  ______
# # Объявите внешнюю функцию с именем counter_add и следующей сигнатурой:
# # def counter_add(n): ...
# # В функции counter_add, объявите вложенную функцию, которая имеет один параметр и увеличивает его значение на величину
# # n - параметр внешней функции. При этом внешняя функция counter_add должна возвращать ссылку на вложенную функцию.
# # Вызовите внешнюю функцию counter_add со значением аргумента 2 и результат присвойте переменной cnt. То есть, переменная
# # cnt будет ссылаться на вложенную функцию. Вызовите внутреннюю функцию через переменную cnt со значением k,
# # которое следует прочитать из входного потока командой:
# # k = int(input())
# # Выведите результат работы вложенной функции на экран.
# def counter_add(n):
#     def add_inner(counter):
#         counter += n
#         return counter
#
#     return add_inner
#
#
# k = int(input())
# cnt = counter_add(2)
# print(cnt(k))

# # ______  Задание 253  ______
# # Реализуйте в программе следующее замыкание функций. Объявите внешнюю функцию без параметров. В ее теле объявите
# # вложенную функцию с одним параметром, в который будет передаваться строка. При этом внешняя функция должна возвращать
# # ссылку на вложенную функцию. Вложенная функция должна заключать переданную через параметр строку в тег h1 и возвращать
# # результат. Например, подается строка "Python", вложенная функция должна вернуть строку:
# # "<h1>Python</h1>"
# # Далее, на вход программы поступает строка, которую следует прочитать из входного потока. Затем, вызовите внешнюю
# # функцию для получения ссылки на вложенную функцию. Через эту ссылку вызовите вложенную функцию с передачей ей
# # прочитанной строки. Результат работы вложенной функции выведите на экран.
# def func1():
#     def func2(str1):
#         str_tag = f'<h1>{str1}</h1>'
#         return str_tag
#
#     return func2
#
# str1 = input()
# fn = func1()
# print(fn(str1))

# # ______  Задание 254  ______
# # Реализуйте в программе следующее замыкание функций. Объявите внешнюю функцию с одним параметром tag, в который будет
# # передаваться тег (строка). В теле внешней функции объявите вложенную функцию с одним параметром, в который будет
# # передаваться строка, заключаемая в тег. При этом внешняя функция должна возвращать ссылку на вложенную функцию.
# # Вложенная функция должна заключать переданную через параметр строку в тег tag, содержащийся в параметре внешней функции
# # и возвращать результат. Например, подается строка "Python", параметр tag="div", вложенная функция должна вернуть строку:
# # "<div>Python</div>"
# # Далее, на вход программы поступают две строки: первая с тегом, вторая с некоторым содержимым. Прочитайте эти строки
# # и вызовите внешнюю функцию с передачей ей прочитанного тега. Через ссылку на вложенную функцию вызовите ее с передачей
# # ей прочитанной (второй) строки. Результат работы вложенной функции выведите на экран.
# def func1(tag):
#     def func2(str1):
#
#         tag_str = f'<{tag}>{str1}</{tag}>'
#
#         return tag_str
#
#     return func2
#
# tag_in = input()
# str_in = input()
# fn = func1(tag_in)
# print(fn(str_in))

# # ______  Задание 255  ______
# # Реализуйте в программе следующее замыкание функций. Объявите внешнюю функцию с одним параметром tp, в который будет
# # передаваться тип коллекции (строка). В теле внешней функции объявите вложенную функцию с одним параметром, которая
# # преобразует строку (переданную через параметр) с набором целых чисел, записанных через пробел, либо в список, либо
# # в кортеж. Тип коллекции определяется параметром tp внешней функции. Если tp = 'list', то используется список, иначе
# # (при другом значении) - кортеж. При этом внешняя функция должна возвращать ссылку на вложенную функцию.
# # Далее, на вход программы поступают две строки: первая - это значение для параметра tp; вторая - последовательность
# # целых чисел, записанных через пробел. Прочитайте их и с помощью реализованного замыкания преобразуйте эти данные в
# # соответствующую коллекцию. Результат работы вложенной функции (сохраненный через переменную lst) выведите на экран командой:
# # print(lst)
# # Обратите внимание, что в возвращаемой коллекции должны присутствовать числа, а не их строковые представления.
# def fun1(tp):
#     def fun2(str1):
#         if tp == 'list':
#             lst = list(map(int, str1.split()))
#         else:
#             lst = tuple(map(int, str1.split()))
#         return lst
#
#     return fun2
#
# tp = input()
# str_in = input()
# fn = fun1(tp)
# print(fn(str_in))

# # ______  Задание 256  ______
# #  Объявите функцию с именем get_sq, которая вычисляет площадь прямоугольника по двум параметрам: width и height -
# #  ширина и высота прямоугольника, и возвращает результат (сама ничего на экран не выводит). То есть, функция имеет сигнатуру:
# # def get_sq(width, height): ...
# # Определите декоратор func_show для этой функции, который отображает результат на экране в виде строки (без кавычек):
# # "Площадь прямоугольника: <значение>"
# # Вызывать функцию и декоратор не нужно, только объявить. Применять декоратор к функции также не нужно.
# def func_show(func):
#     def wrapper(*args):
#         res = func(*args)
#         print(f'Площадь прямоугольника: {res}')
#
#     return wrapper
#
#
# def get_sq(width, height):
#     return width * height

# # ______  Задание 257  ______
# # На вход программы поступает строка с названиями пунктов меню, записанные в одну строчку через пробел. В программе
# # реализовано чтение этой строки командой:
# # menu = input()
# # Необходимо задать функцию с именем get_menu с сигнатурой:
# # def get_menu(s): ...
# # которая преобразует переданную ей строку s в список из слов и возвращает этот список.
# # Определите декоратор для этой функции с именем show_menu, который отображает список на экран в формате:
# # 1. Пункт_1
# # 2. Пункт_2
# # ...
# # N. Пункт_N
# # Примените декоратор show_menu к функции get_menu, используя оператор @. Более ничего в программе делать не нужно.
# # Сами функции не вызывать.
# menu = input() # чтение пунктов меню (переменную menu не менять)
#
# def show_menu(func):
#     def inner(lst):
#         lst = func(lst)
#         for i, v in enumerate(lst):
#             print(f'{i+1}. {v}')
#
#     return inner
#
# @show_menu
# def get_menu(s):
#     res = list(s.split())
#     return res

# # ______  Задание 258  ______
# # На вход программы поступает строка из целых чисел, записанных через пробел. Необходимо прочитать эту строку и сохранить
# # в какой-либо переменной.
# # Напишите функцию get_list с одним параметром, которая преобразовывает эту строку в список из целых чисел и возвращает
# # его. Определите декоратор для функции get_list, который сортирует список чисел по возрастанию. Результат сортировки
# # должен возвращаться в виде списка чисел при вызове декорированной функции.
# # Вызовите декорированную функцию get_list и отобразите полученный отсортированный список lst командой:
# # print(*lst)
# numbers = input()
#
# def func_decorator(func):
#     def inner(n):
#         lst = sorted(func(n))
#         return lst
#
#     return inner
#
# @func_decorator
# def get_list(n):
#     return list(map(int, n.split()))
#
#
# print(*get_list(numbers))

# решение другого ученика
# def show_sorted(func):
#     return lambda *args, **kwards: sorted(func(*args, **kwards))
#
# @show_sorted
# def get_list(s):
#     return list(map(int, s.split()))
#
# print(*get_list(input()))

# # ______  Задание 259  ______
# #  На вход программе поступают две строки. В каждой строке записаны слова через пробел. Прочитайте эти строки и сохраните их в двух переменных.
# # Объявите функцию с двумя параметрами, которой передаются строки со словами и преобразовываются в два списка из слов. Функция должна возвращать кортеж с этими списками в порядке: сначала первый список (первой строки), затем - второй.
# # Определите декоратор для этой функции, который из двух списков формирует словарь, в котором ключами являются слова из первого списка, а значениями - соответствующие элементы из второго списка. Длины списков полагаются равными. Полученный словарь должен возвращаться при вызове декоратора.
# # Примените декоратор к первой функции и вызовите ее для прочитанных строк. Результат (словарь d) отобразите на экране командой:
# # print(*sorted(d.items()))
# str1 = input()
# str2 = input()
#
# def func_decor(func):
#     def inner(*args):
#         res1, res2 = func(*args)
#         d = {res1[i]: res2[i] for i in range(len(res1))}
#
#         return d
#
#     return inner
#
# @func_decor
# def get_lst(a, b):
#     a = a.split()
#     b = b.split()
#     return a, b
#
# print(*sorted(get_lst(str1, str2).items()))

# # ______  Задание 260  ______
# # Объявите функцию, которая принимает строку с кириллицей и латиницей и преобразовывает русские символы в латиницу, используя следующий словарь для замены русских букв на соответствующее латинское написание:
# #
# # t = {'ё': 'yo', 'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ж': 'zh',
# #      'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm', 'н': 'n', 'о': 'o', 'п': 'p',
# #      'р': 'r', 'с': 's', 'т': 't', 'у': 'u', 'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch', 'ш': 'sh',
# #      'щ': 'shch', 'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya'}
# # Функция должна возвращать преобразованную строку. Замены делать без учета регистра (переданную строку перевести в нижний регистр - малые буквы). Небуквенные символы " : ;.,_" превращать в символ '-' (дефиса).
# #
# # Определите декоратор для этой функции, который несколько подряд идущих дефисов, превращает в один дефис. Полученная строка должна возвращаться при вызове декоратора. (Сам декоратор на экран ничего выводить не должен).
# #
# # Примените декоратор к первой функции и вызовите ее для строки s, прочитанной из входного потока командой:
# #
# # s = input()
# # Результат работы декорированной функции отобразите на экране.
# t = {'ё': 'yo', 'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ж': 'zh',
#      'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm', 'н': 'n', 'о': 'o', 'п': 'p',
#      'р': 'r', 'с': 's', 'т': 't', 'у': 'u', 'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch', 'ш': 'sh',
#      'щ': 'shch', 'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya'}
#
# s = input().lower()
#
#
# def func_decor(func):
#     def inner(str1):
#         res = func(str1)
#         while '--' in res:
#             res = res.replace('--','-')
#
#         return res
#
#     return inner
#
#
# @func_decor
# def transcript(s):
#     lst = []
#     for i in s:
#         if i in t:
#             lst.append(t[i])
#         elif i in ' : ;.,_':
#             lst.append('-')
#         else:
#             lst.append(i)
#
#     return ''.join(lst)
#
# print(transcript(s))

# # ______  Задание 261  ______
# # На вход программе подаются целые числа, записанные через пробел. Прочитайте эту строку и сохраните через какую-либо переменную.
# # Напишите функцию, которая имеет один параметр, преобразовывает переданную ей строку в список чисел и возвращает их сумму.
# # Определите декоратор для этой функции, который имеет один параметр start - начальное значение суммы.
# # Примените декоратор со значением start=5 к функции и вызовите декорированную функцию для прочитанной строки. Результат (сумму) отобразите на экране.
# numbs = input()
#
#
# def func_param_decor(start=0):
#     def func_decor(func):
#         def inner(*args):
#             res = func(*args) + start
#             return res
#
#         return inner
#
#     return func_decor
#
#
# @func_param_decor(start=5)
# def get_lst(n):
#     return sum(list(map(int, n.split())))
#
# print(get_lst(numbs))

# # ______  Задание 262  ______
# #  Объявите функцию, которая переводит символы строки в нижний регистр (малые буквы) и возвращает результат.
# # Определите декоратор для этой функции, который имеет один параметр tag, определяющий строку с названием тега и начальным значением "h1". Этот декоратор должен заключать возвращенную функцией строку в тег tag и возвращать результат.
# # Пример заключения строки "python" в тег h1:
# # <h1>python</h1>
# # Примените декоратор со значением tag="div" к функции и вызовите декорированную функцию для строки s, прочитанной из входного потока:
# # s = input()
# # Результат работы декорированной функции отобразите на экране.
# def func_param_decor(tag='h1'):
#     def func_decor(func):
#         def wrapper(*args):
#             new_str = func(*args)
#             return f'<{tag}>{new_str}</{tag}>'
#
#         return wrapper
#
#     return func_decor
#
#
# @func_param_decor(tag='div')
# def do_lower(str_in):
#     return str_in.lower()
#
#
# s = input()
# print(do_lower(s))

# # ______  Задание 263  ______
# # Объявите функцию, которая принимает строку с кириллицей (и другими символами) и преобразовывает русские буквы в латиницу, используя следующий словарь для замены русских букв на соответствующее латинское написание:
# # t = {'ё': 'yo', 'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ж': 'zh',
# #      'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm', 'н': 'n', 'о': 'o', 'п': 'p',
# #      'р': 'r', 'с': 's', 'т': 't', 'у': 'u', 'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch', 'ш': 'sh',
# #      'щ': 'shch', 'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya'}
# # Функция должна возвращать преобразованную строку. Замены делать без учета регистра (переданную строку перевести в нижний регистр - малые буквы).
# # Определите декоратор с параметром chars и начальным значением " !?", который данные символы преобразует в символ "-" и, кроме того, все подряд идущие дефисы (например, "--" или "---") приводит к одному дефису. Полученный результат должен возвращаться в виде строки.
# # Примените декоратор с аргументом chars="?!:;,. " к функции и вызовите декорированную функцию для строки s:
# # s = input()
# # Результат работы декорированной функции отобразите на экране.
# t = {'ё': 'yo', 'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ж': 'zh',
#      'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm', 'н': 'n', 'о': 'o', 'п': 'p',
#      'р': 'r', 'с': 's', 'т': 't', 'у': 'u', 'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch', 'ш': 'sh',
#      'щ': 'shch', 'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya'}
#
# s = input().lower()
#
# def func_param_decor(chars=" !?"):
#     def func_decor(func):
#         def inner(str1):
#             res = func(str1)
#             for i in res:
#                 if i in chars:
#                     res = res.replace(i, '-')
#
#             while '--' in res:
#                 res = res.replace('--','-')
#
#             return res
#
#         return inner
#
#     return func_decor
#
#
# @func_param_decor(chars='?!:;,. ')
# def transcript(s):
#     lst = []
#     for i in s:
#         if i in t:
#             lst.append(t[i])
#         else:
#             lst.append(i)
#
#     return ''.join(lst)
#
# print(transcript(s))

# # ______  Задание 264  ______
# # Объявите функцию с именем get_list, одним параметром и следующим описанием в теле функции:
# # '''Функция для формирования списка целых значений'''
# # Сама функция должна формировать и возвращать список целых чисел, который передается ей на вход в виде строки из целых чисел, записанных через пробел.
# # Определите декоратор, который выполняет суммирование значений списка, возвращаемого декорируемой функцией и возвращает результат. Внутри декоратора декорируйте переданную функцию с помощью команды @wraps (не забудьте сделать импорт: from functools import wraps).
# # Такое декорирование необходимо, чтобы исходная функция get_list сохраняла свои локальные свойства: __name__ и __doc__.
# # Примените декоратор к функции get_list, но не вызывайте ее.
# from functools import wraps
#
# def func_decor(func):
#     @wraps(func)
#     def wrapper(*args):
#         n = sum(func(*args))
#
#         return n
#     return wrapper
#
#
# @func_decor
# def get_list(str_in):
#     '''Функция для формирования списка целых значений'''
#     lst = list(map(int, str_in.split()))
#     return lst

# # ______  Задание 265  ______
# # На вход программе подается вещественное число. Необходимо его прочитать, импортировать модуль math, вызывать функцию ceil модуля math для прочитанного числа и отобразить результат на экране.
# from math import ceil
#
# n = float(input())
# print(ceil(n))

# # ______  Задание 266  ______
# # На вход программе подается вещественное число. Необходимо его прочитать, импортировать только одну функцию floor из модуля math, вызывать ее для прочитанного числа и отобразить результат на экране.
# from math import floor
#
# n = float(input())
# print(floor(n))

# # ______  Задание 267  ______
# # В программе имеется функция factorial (см. листинг). В начале программы (до определения функции) необходимо из модуля math импортировать функцию с тем же именем factorial, используя команду from, но так, чтобы они не "затирали" друг друга. Имя импортируемой функции в модуле (программе) должно быть fact.
# # Уже объявленную функцию не менять. Выполнять функции не нужно, только прописать импорт.
# from math import factorial as fact
#
# def factorial(n):
#     p = 1
#     for i in range(2, n+1):
#         p *= i
#
#     print("my factorial")
#     return p

# # ______  Задание 268  ______
# # Из модуля random импортируйте только две функции: seed и randint. Затем, в программе выполните их следующим образом:
# # seed(1)
# # print(randint(10, 50))
# from random import seed, randint
#
# seed(1)
# print(randint(10, 50))

# # ______  Задание 269  ______
# # Из модуля random импортируйте только две функции: seed и random, но у последней должен быть синоним rnd (имя, через которое она будет вызываться в программе). Выполните в программе эти функции, следующим образом:
# # seed(10)
# # print(round(rnd(), 2))
# from random import seed, random as rnd
# seed(10)
# print(round(rnd(), 2))

# # ______  Задание 270  ______
# # Имеется фрагмент программы (см. листинг ниже). При его выполнении возникает ошибка FileNotFoundError. Запишите конструкцию try / except, чтобы отображалось сообщение "File Not Found", если файл не удается открыть.
# try:
#     f = open("abc.txt")
#     r = f.read(1)
#     f.close()
# except FileNotFoundError:
#     print('File Not Found')

# # ______  Задание 271  ______
# # Запишите выражение для генератора, который бы возвращал целые числа от 2 по 10 000 (включительно) с шагом 1 (то есть, 2, 3, 4, ..., 10 000). Присвойте этот генератор переменной gen.
# # Вызывать генератор и отображать что-либо на экране не нужно, только задать его.
# gen = (x for x in range(2, 10001))

# # ______  Задание 272  ______
# # На вход программе поступают два целых числа a и b (a < b), записанные в одну строчку через пробел. На их основе запишите генератор для формирования квадратов чисел в диапазоне [a; b] (включительно, квадратные скобки об этом говорят).
# # Преобразуйте этот генератор в кортеж чисел (без использования операторов циклов) и присвойте эту коллекцию переменной tp.
# # P. S. На экране ничего отображать не нужно, только создать кортеж на основе генератора.
# a, b = map(int, input().split())
# tp = tuple(x ** 2 for x in range(a, b + 1))

# # ______  Задание 273  ______
# # На вход программе поступают два целых числа a и b (a < b), записанные в одну строчку через пробел. Определите генератор, который бы выдавал модули целых чисел из диапазона [a; b] (включительно). В цикле выведите первые пять значений этого генератора. Каждое значение с новой строки. (Гарантируется, что пять значений имеются).
# a, b = map(int, input().split())
# gen = (abs(x) for x in range(a, b + 1))
# counter = 0
# for i in gen:
#     print(i)
#     counter += 1
#     if counter > 4:
#         break

# решение другого ученика
# a, b = map(int, input().split())
# gen = (abs(x) for x in range(a, b + 1))
# for i in range(5):
#     print(next(gen))

# решение другого ученика
# a, b = map(int, input().split())
# print(*list(abs(i) for i in range(a, b))[:5], sep='\n')

# # ______  Задание 274  ______
# #  На вход программе подается целое положительное число a. Необходимо его прочитать и объявить генератор, который бы возвращал модули чисел в диапазоне [-a; a] (включительно), а затем еще один генератор, который бы вычислял кубы чисел (возведение в степень 3), возвращаемых первым генератором.
# # Вывести в одну строчку через пробел первые четыре значения. (Гарантируется, что генератор выдает, как минимум четыре значения).
# a = int(input())
# gen1 = (abs(x) for x in range(-a, a + 1))
# gen2 = (x ** 3 for x in gen1)
# for i in range(4):
#     print(next(gen2), end=' ')

# # ______  Задание 275  ______
# # Используя символы малых букв латинского алфавита (строка ascii_lowercase):
# # from string import ascii_lowercase
# # запишите генератор, который бы возвращал все возможные сочетания из двух букв латинского алфавита. Выведите первые 50 сочетаний на экран в строку через пробел.
# # Например, первые семь начальных сочетаний имеют вид:
# # aa ab ac ad ae af ag
# # print(ascii_lowercase) ==> abcdefghijklmnopqrstuvwxyz
# from string import ascii_lowercase
# gen = (i + j for i in ascii_lowercase for j in ascii_lowercase)
# for i in range(50):
#     print(next(gen), end=' ')

# решение другого ученика
# from string import ascii_lowercase
#
# gen = (i + j for i in ascii_lowercase for j in ascii_lowercase)
# [print(next(gen), end= ' ') for _ in range(50)]

# # ______  Задание 276  ______
# # Объявите в программе следующий список из названий городов:
# # cities = ["Москва", "Ульяновск", "Самара", "Уфа", "Омск", "Тула"]
# # Затем, необходимо объявить генератор, который бы используя этот список, выдавал 1 000 000 наименований городов по циклу. То есть, дойдя до конца списка, возвращался в начало и повторял перебор. И так, для выдачи миллиона названий. Вывести на экран первые 20 наименований городов с помощью генератора в одну строчку через пробел.
# cities = ["Москва", "Ульяновск", "Самара", "Уфа", "Омск", "Тула"]
# gen = (city for city in cities  * 1000000)
# for i in range(20):
#     print(next(gen), end=' ')

# # ______  Задание 277  ______
# # Необходимо объявить генератор, который бы выдавал значения функции
# #  −2 для аргумента x в диапазоне [a; b] (включительно) с шагом 0.01. Целые числа a, b (a< b) подаются на вход программе в одну строчку через пробел. Нужно их прочитать и через генератор вывести на экран первые 20 значений функции с точностью до сотых.
# # P.S. Значения функции в генераторе вычислять командой:
# # f(x) = 0.5 * pow(x, 2) - 2.0
# a, b = map(int, input().split())
# gen = (0.5 * pow(x / 100, 2) - 2.0 for x in range(100 * a, 100 * b + 1))
# for i in range(20):
#     print(round(next(gen), 2), end=' ')

# # ______  Задание 278  ______
# # На вход программе подается натуральное число N. Оно уже читается в программе командой:
# # N = int(input())
# # Объявите в программе функцию-генератор с именем get_sum с сигнатурой:
# # def get_sum(total): ...
# # которая бы возвращала текущую сумму чисел последовательности длины total = N в диапазоне целых чисел [1; N] (включительно). То есть, при вызове get_sum в качестве аргумента передается переменная N. В результате должны получить следующие результаты работы функции-генератора:
# # при первом вызове get_sum возвращает сумму 1;
# # при втором вызове get_sum возвращает сумму чисел 1+2 = 3;
# # при третьем вызове get_sum возвращает сумму чисел 1+2+3 = 6;
# # ....
# # для N-го вызова get_sum возвращает сумму
# # Реализовать функцию-генератор get_sum без использования коллекций. Вызывать ее не нужно, только объявить.
# N = int(input())
#
#
# def get_sum(total):
#     counter = 0
#     for i in range(1, total + 1):
#         counter += i
#         yield counter

# # ______  Задание 279  ______
# # Мы с вами в заданиях несколько раз генерировали последовательность чисел Фибоначчи, которая строится по правилу: каждое последующее число равно сумме двух предыдущих. Для разнообразия давайте будем генерировать каждое последующее как сумму трех предыдущих чисел. При этом первые три числа равны 1. Получаем такую последовательность:
# # 1, 1, 1, 3, 5, 9, 17, 31, 57, ...
# # Не знаю, есть ли у нее название, поэтому, в рамках уроков, я скромно назову ее последовательностью Балакирева.
# # Итак, на вход программе поступает натуральное число N (N > 5), которое необходимо прочитать и сохранить в переменной. Затем (или в начале программы), объявить функцию-генератор с сигнатурой:
# # def balak_seq(max_len): ...
# # которая бы возвращала max_len = N первых чисел последовательности Балакирева (включая первые три единицы).
# # Реализуйте эту функцию без использования коллекций (списков, кортежей, словарей и т.п.). Вызовите ее N раз для получения N чисел и выведите полученные числа на экран в одну строчку через пробел.
# def balak_seq(max_len):
#     a, b, c = 1, 1, 1
#     for i in range(max_len - 1):
#         if i == 0:
#             yield a
#         a, b, c = b, c, a + b + c
#         yield a
#
#
# N = int(input())
# a = balak_seq(N)
# print(*a)

# # ______  Задание 280  ______
# # На вход программе подается натуральное число N (N > 8). Необходимо его прочитать и объявить функцию-генератор, которая бы выдавала пароль длиной N символов из случайных букв, цифр и некоторых других знаков. Значение N передается в функцию-генератор первым аргументом. Для получения последовательности допустимых символов для генерации паролей в программе импортированы две строки: ascii_lowercase, ascii_uppercase (см. листинг ниже), на основе которых формируется общий список:
# # from string import ascii_lowercase, ascii_uppercase
# # chars = ascii_lowercase + ascii_uppercase + "0123456789!?@#$*"
# # Функция-генератор должна при каждом вызове возвращать новый пароль из случайно выбранных символов chars длиной N и делать это бесконечно, то есть, вызывать ее можно бесконечное число раз.
# # Сгенерируйте с помощью функции-генератора первые пять паролей и выведите их в столбик (каждый с новой строки).
# # Подсказка: сгенерировать случайный индекс indx в диапазоне [a; b] для выбора символа из chars можно с помощью функции randint модуля random:
# # import random
# # random.seed(1)
# # indx = random.randint(a, b)
# import random
# from string import ascii_lowercase, ascii_uppercase
#
#
# random.seed(1)
# chars = ascii_lowercase + ascii_uppercase + "0123456789!?@#$*"
#
# N = int(input())
#
#
# def new_password(N):
#
#     for i in range(N):
#         indx = random.randint(0, len(chars))
#         yield chars[indx]
#
#
# print(*new_password(N), sep='')
# print(*new_password(N), sep='')
# print(*new_password(N), sep='')
# print(*new_password(N), sep='')
# print(*new_password(N), sep='')

# # ______  Задание 281  ______
# # На вход программе подается натуральное число N, которое необходимо прочитать и сохранить через переменную. Используя строки из латинских букв ascii_lowercase и ascii_uppercase:
# # from string import ascii_lowercase, ascii_uppercase
# # chars = ascii_lowercase + ascii_uppercase
# # объявите функцию-генератор с одним параметром max_size, которая бы возвращала случайно сформированные email-адреса с доменом mail.ru и длиной max_size = N символов. Например, при N=6 адрес может выглядеть так: SCrUZo@mail.ru
# # Функция-генератор должна возвращать бесконечное число таких адресов, то есть, генерировать постоянно. Выведите первые пять сгенерированных email и выведите их в столбик (каждый с новой строки).
# # Подсказка: для формирования случайного индекса для выбора символа из строки chars, используйте функцию randint модуля random:
# # import random
# # random.seed(1)
# # indx = random.randint(0, len(chars)-1)
# import random
# from string import ascii_lowercase, ascii_uppercase
#
# random.seed(1)
# chars = ascii_lowercase + ascii_uppercase
#
# N = int(input())
#
#
# def new_password(max_size):
#     m_str = ''
#
#     for i in range(max_size):
#         indx = random.randint(0, len(chars))
#         m_str += chars[indx]
#     yield m_str + '@mail.ru'
#
# for i in range(5):
#     print(*new_password(N))

# # ______  Задание 282  ______
# # Объявите функцию-генератор, которая бы возвращала простые числа. (Простое число - это натуральное число, которое делится только на себя и на 1). Выведите с помощью этой функции первые 20 простых чисел (начиная с 2) в одну строчку через пробел.
# def natural_num():
#     for i in range(2, 200):
#         if i == 2 or i == 3 or i == 5 or i == 7:
#             yield i
#         if i % 2 != 0 and i % 3 != 0 and i % 5 != 0 and i % 7 != 0:
#             yield i
#
#
# a = natural_num()
# for i in range(20):
#     print(next(a), end=' ')

# # ______  Задание 283  ______
# #  На вход программе поступает строка с вещественными числами, записанными через пробел. Необходимо прочитать эту строку. Затем, с помощью функции map преобразовать числа в строке в их вещественное представление и отобразить первые три числа. (Полагается, что минимум три вещественных числа имеются). Реализовать извлечение чисел через функцию next. Результат отобразить в строчку через пробел.
# numbers_in = map(float, input().split())
# for i in range(3):
#     print(next(numbers_in), end=' ')

# # ______  Задание 284  ______
# #  На вход программе поступает строка из целых чисел, записанных через пробел. Необходимо прочитать эту строку. Затем, с помощью функции map преобразовать эту строку в список целых чисел, взятых по модулю. Сформируйте именно список lst из таких чисел. Отобразите его на экране командой:
# # print(*lst)
# lst = list(map(abs, map(int, input().split())))
# print(*lst)

# # ______  Задание 285  ______
# # На вход программе подается таблица целых чисел. Строки этой таблицы уже в программе читаются командой:
# # lst_in = list(map(str.strip, sys.stdin.readlines()))
# # Далее, используя функцию map и генератор списков, преобразуйте строки списка lst_in в двумерный (вложенный) список с именем lst2D, содержащий целые числа (а не их строковое представление). Сам список lst_in не менять.
# # Выводить на экран ничего не нужно, только сформировать список lst2D на основе введенных данных.
# lst_in = ['8 11 -5', '3 4 10', '-1 -2 3', '-4 5 6']
# lst2D = [list(map(int, i.split())) for i in lst_in]

# # ______  Задание 286  ______
# # На вход программе подается строка в формате:
# # ключ_1=значение_1 ключ_2=значение_2 ... ключ_N=значение_N
# # Необходимо ее прочитать и с помощью функции map преобразовать ее в кортеж tp вида:
# # tp = (('ключ_1', 'значение_1'), ('ключ_2', 'значение_2'), ..., ('ключ_N', 'значение_N'))
# # Выводить на экран ничего не нужно, только преобразовать строку в кортеж с именем tp.
# # s = input()
# # s_lst = s.split()
# # tp = tuple(tuple(i.split('=')) for i in s_lst)
#
# s = input()
# s_lst = s.split()
# tp = tuple(map(lambda i: tuple(i.split('=')), s_lst))

# # ______  Задание 287  ______
# # (Для учебных целей). На вход программе подается строка. Необходимо ее прочитать и в ней заменить кириллические символы на соответствующие латинские обозначения (без учета регистра букв), а все остальные символы - на символ дефиса (-). Для этого в программе уже объявлен словарь (см. листинг):
# # t = {'ё': 'yo', 'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ж': 'zh',
# #      'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm', 'н': 'n', 'о': 'o', 'п': 'p',
# #      'р': 'r', 'с': 's', 'т': 't', 'у': 'u', 'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch', 'ш': 'sh',
# #      'щ': 'shch', 'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya'}
# # Используя его, примените функцию map, которая бы выдавала преобразованные фрагменты для входной строки. На основе этой функции сформируйте строку, состоящую из преобразованных фрагментов (фрагменты в строке должны идти друг за другом без пробелов). Отобразите результат на экране.
# t = {'ё': 'yo', 'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ж': 'zh',
#      'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm', 'н': 'n', 'о': 'o', 'п': 'p',
#      'р': 'r', 'с': 's', 'т': 't', 'у': 'u', 'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch', 'ш': 'sh',
#      'щ': 'shch', 'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya'}
#
# # здесь продолжайте программу
# str_in = input().lower()
# new_str = ''.join(map(lambda x: t[x] if x in t else '-', str_in))
#
# print(new_str)

# # ______  Задание 288  ______
# # На вход программе подается строка с названиями городов, записанных в одну строчку через пробел. Необходимо ее прочитать и применить функцию map так, чтобы она возвращала названия городов только длиной более 5 символов. Вместо остальных названий - строку с дефисом ("-"). Сформировать список из полученных значений и отобразить его на экране в одну строчку через пробел.
# cities = input().split()
# shorts = list(map(lambda x: x if len(x) > 5 else '-', cities))
# print(*shorts)

# # ______  Задание 289  ______
# # На вход программе подается строка с названиями городов, записанных через пробел. Необходимо прочитать эту строку и применить функцию filter, которая бы возвращала только названия длиной более 5 символов. Извлеките первые три полученных значения с помощью функции next и отобразите их на экране в одну строчку через пробел. (Полагается, что минимум три значения имеются).
# cities = filter(lambda x: len(x) > 5, input().split())
# for i in range(3):
#     print(next(cities), end=' ')

# # ______  Задание 290  ______
# # На вход программе подается список предметов в виде строк формата:
# # название_1=вес_1
# # ...
# # название_N=вес_N
# # В программе уже реализовано их считывание в список lst_in:
# # lst_in = list(map(str.strip, sys.stdin.readlines()))
# # С помощью функции map, необходимо сначала преобразовать этот список строк в кортеж, элементами которого также являются кортежи, то есть, представить список в формате:
# # (('название_1', 'вес_1'), ..., ('название_N', 'вес_N'))
# # А, затем, отфильтровать (исключить) все предметы с весом менее 500, используя функцию filter. Вывести на экран список оставшихся предметов (только их названия) в одну строчку через пробел в порядке их следования во входных данных.
# lst_in = ['зонт=1000', 'палатка=10000', 'спички=22', 'котелок=543']
#
# new_tpl = tuple(map(lambda x: tuple(x.split('=')), lst_in))
#
# tpl = list(map(lambda x: x[0], filter(lambda x: int(x[1]) > 500, new_tpl)))
#
# print(*tpl)

# # решение другого ученика
# import sys
#
# lst_in = list(map(str.strip, sys.stdin.readlines()))
# f = filter(lambda x: int(x[1]) >= 500, tuple(map(lambda x: tuple(x.split('=')), lst_in)))
# print(*(item for item, weight in f))

# # ______  Задание 291  ______
# # На вход программе подаются целые числа, записанные через пробел. Необходимо их прочитать и оставить среди них только двузначные числа. Реализовать программу с использованием функции filter. Результат отобразить на экране в виде последовательности оставшихся чисел в одну строчку через пробел.
# numbers = list(map(int, input().split()))
# lst = filter(lambda x: 0 < abs(x) // 10 < 10, numbers)
# print(*lst)

# решение другого ученика
# print(*filter(lambda x: 9 < abs(x) < 100, map(int, input().split())))

# # ______  Задание 292  ______
# # Саша и Галя коллекционируют монетки. Каждый из них решил записать номиналы монеток из своей коллекции. Получились две последовательности. Эти последовательности чисел (номиналов) поступают на вход программе в виде двух строк из целых чисел, записанных через пробел. Необходимо их прочитать и выделить значения, присутствующие в обоих списках, а затем, оставить среди них только четные. Результат вывести на экран в виде строки полученных чисел в порядке их возрастания через пробел.
# # При реализации программы используйте функцию filter и кое-что еще (для упрощения программы), подумайте что.
# col_1 = set(map(int, input().split()))
# col_2 = set(map(int, input().split()))
# inter_col = filter(lambda x: x % 2 == 0, col_1 & col_2)
# print(*sorted(inter_col))

# решение другого ученика
# a = list(map(int, input().split()))
# b = list(map(int, input().split()))
#
# sm = sorted(filter(lambda x: x in b and x % 2 == 0, a))
# print(*sm)

# решение другого ученика
# a, b = map(str.split, (input(), input()))
# print(*filter(lambda a: int(a) % 2 == 0, set(a)&set(b)))

# # ______  Задание 293  ______
# # На вход программе подается строка с email-адресами, записанных через пробел. Нужно прочитать эту строку и среди email-адресов оставить только корректно записанные адреса. Полагается, что к таким относятся те, что используют только латинские буквы, цифры и символ подчеркивания. Также в адресе должен быть символ "@", а после него символ точки "." (между ними, конечно же, могут быть и другие символы).
# # Результат отобразить в виде строки email-адресов, записанных через пробел в порядке их следования в исходной строке.
# from string import ascii_lowercase, ascii_uppercase
# chars = ascii_lowercase + ascii_uppercase
#
# def correct_mail(str_in):
#     a = False
#     if '@' not in str_in:
#         return False
#     else:
#         start_str, end_str = str_in.split('@')
#         if '.' in end_str:
#             for i in end_str:
#                 if i in chars or i == '_' or i.isdigit() or i == '.':
#                     a = True
#                 else:
#                     return False
#             for i in start_str:
#                 if i in chars or i == '_' or i.isdigit():
#                     a = True
#                 else:
#                     return False
#         else:
#             return False
#     return a
#
#
# mails_lst = list(input().split())
#
# lst = list(filter(correct_mail, mails_lst))
# print(*lst)

# # решение другого ученика
# def is_valid_email(email):
#     email = email.lower()
#     if email.find("@") >= email.find("."):
#         return False
#     for i in email:
#         if i not in "abcdefghijklmnopqrstuvwxyz1234567890_@.":
#             return False
#     return True
# print(*[*filter(is_valid_email, input().split())])

# решение другого ученика
# print(*filter(lambda s: len(set(s.lower())-set('@._0123456789abcdefghijklmnopqrstuvwxyz'))==0 and '.' in s.split('@')[1], input().split()))

# # ______  Задание 294  ______
# # На вход программе поступают две последовательности целых чисел, каждая с новой строки. Необходимо прочитать эти последовательности и сохранить в отдельных списках или кортежах. Затем, попарно перебрать их элементы и перемножить между собой. При реализации программы используйте функции zip и map. Выведите на экран первые три значения, используя функцию next. Значения выводятся в строчку через пробел. (Полагается, что три выходных значения всегда будут присутствовать).
# str_in1 = input().split()
# str_in2 = input().split()
#
# numb_lst  = map(lambda x: int(x[0]) * int(x[1]), zip(str_in1, str_in2))
# for i in range(3):
#     print(next(numb_lst), end=' ')

# # решение другого ученика
# n=map(int, input().split())
# m=map(int, input().split())
# res=(x*y for x,y in zip(n, m))
# for _ in range(3):
#     print(next(res), end= " ")

# # решение другого ученика
# a, b = [map(int, input().split()) for _ in '12']
#
# for _ in '123':
#     v1, v2 = next(zip(a, b))
#     print(v1 * v2, end=' ')

# # ______  Задание 295  ______
# # На вход программе подается неравномерная таблица целых чисел. В программе уже реализовано считывание ее строк  и сохранение в списке lst_in:
# # lst_in = list(map(str.strip, sys.stdin.readlines()))
# # С помощью функции zip необходимо выравнить эту таблицу, приведя ее к прямоугольному виду, отбросив выходящие элементы в строках. Вывести результат на экран в виде такой же таблицы чисел. В конце строк при выводе пробелов быть не должно.
# lst_in = ['1 2 3 4 5 6', '3 4 5 6', '7 8 9', '9 7 5 3 2']
# s = list(map(str.split, lst_in))
#
# a = list(zip(*s))
# b = list(zip(*a))
#
# for c in b:
#     print(*c)

# решение другого ученика
# import sys
#
# # считывание списка из входного потока
# lst_in = list(map(str.strip, sys.stdin.readlines()))
#
# # здесь продолжайте программу (используйте список строк lst_in)
# list(map(print, *zip(*map(str.split, lst_in))))

# # решение другого ученика
# import sys
#
# # считывание списка из входного потока
# lst_in = list(map(str.strip, sys.stdin.readlines()))
#
# for i in zip(*zip(*lst_in)):
#     print(*i, sep='')


# lst_in = ['1 2 3 4 5 6', '3 4 5 6', '7 8 9', '9 7 5 3 2']
#
# b = zip(*zip(*lst_in))
#
# for c in b:
#     print(*c, sep='')

# # ______  Задание 296  ______
# # На вход программе подается таблица целых чисел. В программе уже реализовано считывание ее строк  и сохранение в списке lst_in:
# # lst_in = list(map(str.strip, sys.stdin.readlines()))
# # Необходимо сначала список строк lst_in представить двумерным (вложенным) списком чисел, а затем, с помощью функции zip выполнить транспонирование этой таблицы (то есть, строки заменить на соответствующие столбцы). Результат вывести на экран в виде таблицы чисел (числа в строках следуют через пробел). В конце строк при выводе пробелов быть не должно.
# lst_in = ['1 2 3 4', '5 6 7 8', '9 8 7 6']
# a = zip(*map(str.split, lst_in))
# for i in a:
#     print(*i)

# # решение другого ученика
# import sys
#
# # считывание списка из входного потока
# lst_in = list(map(str.strip, sys.stdin.readlines()))
#
# lst = [list(map(int, i.split())) for i in lst_in]
#
# for i in zip(*lst):
#     print(*i)

# # решение другого ученика
# import sys
#
# # считывание списка из входного потока
# lst_in = list(map(str.strip, sys.stdin.readlines()))
#
# # здесь продолжайте программу (используйте список строк lst_in)
# [print(*i) for i in zip(*map(str.split, lst_in))]

# # ______  Задание 297  ______
# # На вход программе подается строка из слов, записанных через пробел. Необходимо прочитать эту строку, разбить на слова на основе полученного списка составить прямоугольную таблицу из трех столбцов и N строк (число строк столько, сколько получится). Лишнее (выходящее) слово - отбросить. Реализовать эту программу с использованием функции zip. Результат отобразить на экране в виде прямоугольной таблицы из слов, записанных через пробел (в каждой строчке).
# lst_in = iter(input().split())
# a = [*zip(lst_in, lst_in, lst_in)]
# for i in a:
#     print(*i)

# # решение другого ученика
# s = input().split()
#
# lst = [s[i::3] for i in range(len(s) // 3)]
#
# for i in zip(*lst):
#     print(*i)

# # решение другого ученика
# for row in zip(*[iter(input().split())]*3):
#     print(*row)

# # ______  Задание 298  ______
# # На вход программе подается строка. Требуется ее прочитать и сформировать N=10 пар кортежей в формате:
# # (символ, порядковый индекс)
# # Например, подается строка "Sergey Balakirev", на выходе формируются кортежи (сохраненные в списке):
# # [('S', 0), ('e', 1), ('r', 2), ('g', 3), ('e', 4), ('y', 5), (' ', 6), ('B', 7), ('a', 8), ('l', 9)]
# # Первый индекс имеет значение 0. Строка может быть короче 10 символов, а может быть и длиннее. То есть, число пар может быть 10 и менее. Используя функцию zip сформируйте указанные кортежи и сохраните их в списке с именем lst.
# # P.S. Программа ничего не должна отображать на экране, только формировать список lst из кортежей.
# s = input()
# lst = list(zip(s, range(len(s))))
# if len(lst) > 10:
#     lst = lst[:10]

# # решение другого ученика
# s = input()
#
# lst = list(zip(s, range(10)))

# # ______  Задание 299  ______
# # На вход программе поступают целые числа, записанные через пробел. Прочитайте эту строку с числами и преобразуйте ее сначала в список из целых чисел, а затем список в кортеж из целых чисел. То есть, в программе будет две разные коллекции: список и кортеж. Отсортируйте по возрастанию значений эти коллекции методом sort, если это возможно, а иначе - примените функцию sorted.
# # На экран ничего выводить не нужно, только сформировать две отсортированные коллекции: lst (список) - результат сортировки списка; tp_lst (кортеж) - результат сортировки кортежа.
# # P. S. На результаты сортировок обязательно должны ссылаться переменные с именами lst и tp_lst!
# s = input()
# lst = list(map(int, s.split()))
# lst.sort()
# tp_lst = tuple(sorted(map(int, s.split())))

# # ______  Задание 300  ______
# # Объявите в программе функцию со следующей сигнатурой:
# # def get_sort(d): ...
# # На входе этой функции (в параметре d) ожидается словарь формата (пример):
# # d = {'cat': 'кот', 'horse': 'лошадь', 'tree': 'дерево', 'dog': 'собака', 'book': 'книга'}
# # Функция должна выполнить сортировку ключей словаря d по убыванию (лексикографическая сортировка строк) и возвратить список из соответствующих значений ключей словаря. Сам словарь d при этом должен оставаться неизменным. Например, для указанного словаря d, результатом работы функции должен быть список:
# # ['дерево', 'лошадь', 'собака', 'кот', 'книга']
# # В программе нужно реализовать только функцию get_sort, вызывать ее не нужно и что-либо выводить на экран.
# # Подсказка: список в функции get_sort лучше всего формировать с помощью генератора списков.
# def get_sort(d):
#     return [d[i] for i in sorted(d, reverse=True)]

# # ______  Задание 301  ______
# # На вход программе поступают целые числа, записанных через пробел. Необходимо их прочитать и выбрать из них четыре наибольших уникальных значения. Результат вывести на экран в порядке их убывания в одну строчку через пробел.
# str_in = set(map(int, input().split()))
# s = sorted(str_in, reverse=True)
# print(*s[:4])

# решение другого ученика
# print(*sorted(set(map(int, input().split())), reverse=True)[:4])


# # ________________    Задание 302    ____________________
# # На вход программе поступают две последовательности целых чисел (каждая с новой строки). Длины последовательностей могут быть разными. Необходимо их прочитать и сохранить в отдельных списках или кортежах. Затем, первый список отсортировать по возрастанию, а второй - по убыванию. Полученные пары из обоих списков сложить друг с другом и получить новый список чисел. Результат вывести на экран в виде строки чисел через пробел.
# str_in1 = sorted(map(int, input().split()))
# str_in2 = sorted(map(int, input().split()), reverse=True)
# print(*[x + y for x, y in zip(str_in1, str_in2)])


# # ------  решение другого ученика  ------
# lst_1 = sorted(map(int, input().split()))
# lst_2 = sorted(map(int, input().split()))[::-1]
#
# print(*map(sum, zip(lst_1, lst_2)))


# # ________________    Задание 303    ____________________
# # На вход программе поступает список товаров в виде строк формата:
# # название_1:цена_1
# # ...
# # название_N:цена_N
# # В программе уже реализовано считывание всех этих строк и сохранение в списке lst_in:
# # lst_in = list(map(str.strip, sys.stdin.readlines()))
# # Необходимо преобразовать этот список в словарь, ключами которого выступают цены (целые числа), а значениями - соответствующие названия товаров. Также необходимо написать функцию, которая бы принимала на входе словарь указанного формата и возвращала список из наименований трех наиболее дешевых товаров.
# # Вызовите эту функцию и отобразите на экране полученный список в порядке возрастания цены в одну строчку через пробел.
# lst_in = ['смартфон:120000', 'яблоко:2', 'сумка:560', 'брюки:2500', 'линейка:10', 'бумага:500']
# d = {int(y): x for x, y in [i.split(':') for i in lst_in]}
#
# def d_sorted(d):
#     lst = [d[i] for i in sorted(d)]
#     return lst[:3]
#
# print(*d_sorted(d))

# # ------  решение другого ученика  ------
# import sys
# lst_in = list(map(str.strip, sys.stdin.readlines()))
#
# def get_cheap(d):
#     return list(dict(sorted(d.items())[:3]).values())
#
#
# dct = {int(b) : a for a, b in [x.split(':') for x in lst_in]}
# print(*get_cheap(dct))


# # ________________    Задание 304    ____________________
# #  На вход программе поступает строка с наименованиями рек, записанных через пробел. Необходимо их прочитать и отсортировать названия рек в порядке убывания их длин строк (названий). Результат вывести в одну строчку через пробел.
# lst_in = sorted(input().split(), key=len, reverse=True)
# print(*lst_in)



# # ________________    Задание 305    ____________________
# #  На вход программе поступают строки в формате:
# # предмет_1=вес_1
# # ...
# # предмет_N=вес_N
# # Веса предметов заданы целыми числами. В программе уже реализовано их считывание в список lst_in:
# # lst_in = list(map(str.strip, sys.stdin.readlines()))
# # Необходимо на основе этих данных сформировать словарь (ключи - названия предметов, значения - вес предметов) и, затем, на основе этого словаря сформировать список предметов по убыванию их веса. (В списке должны находиться только наименования предметов без их весов).
# # Отобразить полученный список в виде строки с названиями через пробел.
# lst_in = ['ножницы=100', 'котелок=500', 'спички=20', 'зажигалка=40', 'зеркальце=50']
#
#
# d = {i[0] : int(i[1]) for i in [elem.split("=") for elem in lst_in] }
# c = [i[0] for i in sorted(d.items(), key=lambda x: x[1], reverse=True)]
#
# print(*c)


# # ------  решение другого ученика  ------
# import sys
#
# # считывание списка из входного потока
# lst_in = list(map(str.strip, sys.stdin.readlines()))
#
# # здесь продолжайте программу (используйте список строк lst_in)
# d = {k: int(v) for k, v in (line.split('=') for line in lst_in)}
# print(*sorted(d, key=d.get, reverse=True))


# # ________________    Задание 306    ____________________
# # Известно, что порядок нот следующий: до, ре, ми, фа, соль, ля, си. На вход программе поступает строка с набором этих нот, записанных в произвольном порядке через пробел. Необходимо прочитать ноты и сформировать список (с нотами), отсортированными в порядке: до, ре, ми, фа, соль, ля, си. Результирующий список нот вывести в одну строчку через пробел.
# lst_in = input().split()
# lst = ['до', 'ре', 'ми', 'фа', 'соль', 'ля', 'си']
#
# print(*sorted(lst_in, key=lambda elem: lst.index(elem)))


# # ------  решение другого ученика  ------
# s = 'до, ре, ми, фа, соль, ля, си'
# print(*sorted(input().split(), key=s.find))


# # ------  решение другого ученика  ------
# notes = ('до', 'ре', 'ми', 'фа', 'соль', 'ля', 'си')
# print(*sorted(input().split(), key=notes.index))


# # ________________    Задание 307    ____________________
# # Имеется таблица с данными, представленная в формате:
# # Номер;Имя;Оценка;Зачет
# # 1;Иванов;3;Да
# # 2;Петров;2;Нет
# # ...
# # N;Балакирев;4;Да
# #  В программе уже реализовано их считывание в список lst_in:
# # lst_in = list(map(str.strip, sys.stdin.readlines()))
# # Данные этого списка необходимо разбить по разделителю ";" и представить в виде двумерного (вложенного) кортежа в формате:
# # ( ('Номер', 'Имя', 'Оценка', 'Зачет'), (1, 'Иванов', 3, 'Да'), (2, 'Петров', 2, 'Нет'), ... )
# # При этом все числа должны быть представлены как целые числа. Затем, отсортировать этот кортеж так, чтобы столбцы шли в порядке:
# # Имя;Зачет;Оценка;Номер
# # Реализовать эту операцию с помощью сортировки. Результат должен быть представлен также в виде двумерного кортежа и присвоен переменной с именем t_sorted.
# # Программа ничего не должна выводить на экран, только формировать двумерный кортеж с переменной t_sorted.
# lst_in = [
#     'Номер;Имя;Оценка;Зачет',
#     '1;Портос;5;Да',
#     '2;Арамис;3;Да',
#     '3;Атос;4;Да',
#     '4;д\'Артаньян;2;Нет',
#     '5;Балакирев;1;Нет'
# ]
#
# t_list = [str_in.split(';') for str_in in lst_in]
# ind = [3, 0, 2, 1]
# t1 = [sorted(i,key=lambda j: ind[i.index(j)]) for i in t_list]
# t_sorted = tuple(tuple(int(i) if i.isdigit() else i for i in elem) for elem in t1)
# print(t_sorted)


# # ________________    Задание 308    ____________________
# # Известно, что звания военнослужащих имеют следующий порядок (по возрастанию):
# # рядовой, сержант, старшина, прапорщик, лейтенант, капитан, майор, подполковник, полковник
# # На вход программе поступают данные о военнослужащих в формате:
# # имя_1=звание_1
# # ...
# # имя_N=звание_N
# #  В программе уже реализовано их считывание в список lst_in:
# # lst_in = list(map(str.strip, sys.stdin.readlines()))
# # Необходимо данные списка lst_in представить в виде вложенного списка вида:
# # [['имя_1', 'звание_1'], ['имя_2', 'звание_2'], ..., ['имя_N', 'звание_N']]
# # Этот список присвоить переменной с именем lst. Затем, отсортировать его по возрастанию званий.
# # Выводить на экран ничего не нужно, только сформировать список и указать на него переменную lst.
# lst_in = ['Атос=лейтенант',
#           'Портос=прапорщик',
#           'д\'Артаньян=капитан',
#           'Арамис=лейтенант',
#           'Балакирев=рядовой']
# sort_keys = ['рядовой', 'сержант', 'старшина', 'прапорщик', 'лейтенант', 'капитан', 'майор', 'подполковник', 'полковник']
# lst = [[el1, el2] for el1, el2 in [i.split('=') for i in lst_in]]
# lst = list(sorted(lst, key=lambda x: sort_keys.index(x[1])))


# # ------  решение другого ученика  ------
# import sys
#
# # считывание списка из входного потока (переменную lst_in не менять)
# lst_in = list(map(str.strip, sys.stdin.readlines()))
#
# # здесь продолжайте программу (используйте список строк lst_in)
# order = 'рядовой, сержант, старшина, прапорщик, лейтенант, капитан, майор, подполковник, полковник'
# lst = [x.split('=') for x in lst_in]
# lst = sorted(lst, key=lambda x: order.find(x[1]))


# # ________________    Задание 309    ____________________
# # Объявите в программе функцию с именем get_add следующей сигнатуры:
# # def get_add(a, b): ...
# # Функция должна складывать или два числа или две строки (но не число со строкой) и возвращать полученный результат. Если сложение не может быть выполнено, то функция возвращает значение None.
# # Вызывать функцию не нужно, только объявить. Также ничего не нужно выводить на экран.
# # Подсказка: не забудьте про необходимость различения булевых значений (False, True) от целочисленных.
# def get_add(a, b):
#     if type(a) in (int, float) and type(b) in (int, float):
#         return a + b
#     elif type(a) == str and type(b) == str:
#         return a + b
#     else:
#         return None


# # ------  решение другого ученика  ------
# def get_add(a, b):
#     if  {type(a), type(b)} in ({str}, {int}, {float}, {int, float}):
#         return a + b


# # ________________    Задание 310    ____________________
# # Объявите в программе функцию с именем get_sum следующей сигнатуры:
# # def get_sum(it): ...
# # Функция принимает на входе итерируемый объект (список, строку, кортеж, словарь, множество) и вычисляет сумму только целых чисел, взятых из элементов итерируемого объекта. Вычисленная сумма возвращается функцией. Если целых чисел нет, то возвращается 0.
# # Вызывать функцию не нужно, только объявить. Также ничего не нужно выводить на экран.
# # Примеры входного аргумента функции:
# # get_sum([1,2,3, "a", True, [4, 5], "c", (4, 5)])
# # get_sum({5, 6, 7, '8', 5, '4'})
# # get_sum((10, "f", '33', True, 12))
# # get_sum(['1', True, False, (1, 23)])
# def get_sum(it):
#     a = list(filter(lambda x: type(x) is int, it))
#     if a == []:
#         return 0
#     else:
#         return sum(a)


# # ------  решение другого ученика  ------
# def get_sum(it):
#     return sum(filter(lambda x: type(x) == int, it))


# # ________________    Задание 311    ____________________
# # Объявите в программе функцию с именем get_even_sum следующей сигнатуры:
# # def get_even_sum(it): ...
# # Функция принимает на входе итерируемый объект (список, строку, кортеж, словарь, множество) и вычисляет сумму только целых четных чисел, взятых из элементов итерируемого объекта. Результат возвращается функцией. Если целых чисел нет, то возвращается 0.
# # Вызывать функцию не нужно, только определить. Также ничего не нужно выводить на экран.
# # Подсказка: не забудьте про необходимость различения булевых значений (False, True) от целочисленных.
# def get_even_sum(it):
#     return sum(filter(lambda x: type(x) == int and x % 2 == 0, it))


# # ________________    Задание 312    ____________________
# # Объявите в программе функцию с именем get_list_dig следующей сигнатуры:
# # def get_list_dig(lst): ...
# # Функция должна возвращать список только из числовых значений переданной ей коллекции (список или кортеж).
# # Вызывать функцию не нужно, только объявить. Также ничего не нужно выводить на экран.
# # Подсказка: не забудьте про необходимость различения булевых значений (False, True) от целочисленных.
# def get_list_dig(lst):
#     return list(filter(lambda x: type(x) in (int, float), lst))


# # ________________    Задание 313    ____________________
# # На вход программе подаются целые числа, записанные через пробел. Необходимо их прочитать и определить, являются ли все эти числа четными. Вывести True, если это так и False в противном случае.
# # Задачу реализовать с использованием одной из функций: any или all.
# print(True if all(list(map(lambda x: x% 2 ==0 , map(int, input().split())))) else False)


# # ________________    Задание 314    ____________________
# # На вход программе подаются вещественные числа, записанные через пробел. Необходимо их прочитать и определить, есть ли среди них хотя бы одно отрицательное. Вывести True, если это так и False в противном случае.
# # Задачу реализовать с использованием одной из функций: any или all.
# print(True if any(list(map(lambda x: x < 0 , map(float, input().split())))) else False)


# # ________________    Задание 315    ____________________
# # В программе объявите функцию с именем is_string следующей сигнатуры:
# # def is_string(lst): ...
# # Функции передается (через параметр lst) коллекция (список, кортеж, множество). Функция должна возвращать True, если все элементы коллекции lst - строки и False в противном случае.
# # Вызывать функцию не нужно, только объявить. Также ничего не нужно выводить на экран. Задачу реализовать с использованием одной из функций: any или all.
# def is_string(lst):
#     return True if all(map(lambda x: type(x) == str, lst)) else False


# # ________________    Задание 316    ____________________
# # На вход программе подаются оценки студента, записанные через пробел. Необходимо их прочитать и определить, имеется ли в этом списке хотя бы одна оценка ниже тройки. Если это так, то вывести на экран строку "отчислен", иначе - "учится".
# # Задачу реализовать с использованием одной из функций: any или all.
# print("отчислен" if any(map(lambda x: int(x) < 3, input().split())) else "учится")


# # ________________    Задание 317    ____________________
# # На вход программе подается текущее игровое поле для игры "Крестики-нолики" в виде следующей таблицы (списка строк):
# # # x o
# # x # x
# # o o #
# # Здесь # - свободная клетка. В программе уже реализовано чтение этих строк и сохранение в список lst_in:
# # lst_in = list(map(str.strip, sys.stdin.readlines()))
# # Необходимо преобразовать этот список строк в двумерный список с именем pole вида (пример):
# # [ ['#', 'x', 'o'], ['x', '#', 'x'], ['o', 'o', '#'] ]
# # Объявите в программе функцию с именем is_free сигнатуры:
# # def is_free(lst): ...
# # На вход этой функции подается игровое поле в виде двумерного (вложенного) списка. Данная функция должна возвращать True, если есть хотя бы одна свободная клетка и False в противном случае.
# # Вызывать функцию не нужно, только определить. Также ничего не нужно выводить на экран. Задачу реализовать с использованием одной из функций: any или all.
# lst_in = ['# x o',
#           'x # x',
#           'o o #']
# pole = [i.split() for i in lst_in]
#
# def is_free(lst):
#     return True if any(any(map(lambda x: x == '#', i)) for i in lst) else False


# # ------  решение другого ученика  ------
# def is_free(lst):
#     return any('#' in i for i in lst)


# # ________________    Задание 318    ____________________
# # На вход программе подается целое десятичное число. Прочитайте его и, используя битовые операции, включите третий бит введенного числа. Выведите на экран полученное числовое значение.
# # P. S. Распределение номеров бит представлено на следующем рисунке.
# n = int(input())
# print(n | 8)


# # ________________    Задание 319    ____________________
# # На вход программе подается целое десятичное число. Прочитайте его и, используя битовые операции, выключите 4-й и 1-й биты введенного числа. Выведите на экран полученное числовое значение.
# # P. S. Распределение номеров бит представлено на следующем рисунке.
# n = int(input())
# print(n & ~18)


# # ________________    Задание 320    ____________________
# # На вход программе подается целое десятичное число. Прочитайте его и, используя битовые операции, переключите 3-й и 0-й биты введенного числа. Выведите на экран полученное числовое значение.
# # P. S. Распределение номеров бит представлено на следующем рисунке.
# n = int(input())
# print(n ^ 9)


# # ________________    Задание 321    ____________________
# # На вход программе подается целое десятичное число. Прочитайте его и, используя битовые операции, выполните умножение введенного числа на 4. Выведите на экран полученное числовое значение.
# n = int(input())
# print(n << 2)


# # ________________    Задание 322    ____________________
# # На вход программе подается целое десятичное число. Прочитайте его и, используя битовые операции, выполните целочисленное деление введенного числа на 2. Выведите на экран полученное числовое значение.
# n = int(input())
# print(n >> 1)


# # ________________    Задание 323    ____________________
# # На вход программе подается зашифрованное слово. Шифрование кодов символов этого слова было проведено с помощью битовой операции XOR с ключом key=123. То есть, каждый символ был преобразован по алгоритму:
# # x = ord(x) ^ key
# # Здесь ord - функция, возвращающая код символа x. Прочитайте слово из входного потока и расшифруйте его. Выведите на экран результат расшифровки.
# # P. S. Подсказка: для преобразования кода в символ используйте функцию chr.
# str_in = input()
# key=123
# x = [chr(ord(i) ^ key) for i in str_in]
# print(''.join(x))



# # ________________    Задание 324    ____________________
# # На вход программе подается целое десятичное число. Прочитайте его и, используя битовые операции, проверьте, включен ли 6-й и 3-й биты введенного числа. Если они оба включены, то выведите слово "ДА", иначе - слово "НЕТ".
# # P. S. Распределение номеров бит представлено на следующем рисунке.
# n = int(input())
# print("ДА" if n & 72 == 72 else "НЕТ")


# # ________________    Задание 325    ____________________
# # На вход программе подается целое десятичное число. Прочитайте его и, используя битовые операции, проверьте, включен ли 5-й или 1-й биты введенного числа. Если включен хотя бы один из этих битов, то выведите слово "ДА", иначе - слово "НЕТ".
# # P. S. Распределение номеров бит представлено на следующем рисунке.
# n = int(input())
# print("ДА" if n & 34 in (34, 2, 32) else "НЕТ")


# # ------  решение другого ученика  ------
# print("ДА" if int(input()) & 0b100010 else "НЕТ")


# # ________________    Задание 326    ____________________
# # На вход программе подаются два натуральных числа a, b (a < b), записанных через пробел. Прочитайте их и выполните генерацию вещественной случайной величины в диапазоне [a; b). Округлите результат до сотых и выведите его на экран.
# # Ликбез: квадратная скобка - граница включается в диапазон; круглая скобка - граница исключается из диапазона.
# import random
# a, b = map(int, input().split())
# print(round(random.uniform(a, b), 2))


# # ________________    Задание 327    ____________________
# # На вход программе подаются два натуральных числа a, b (a < b), записанные через пробел. Прочитайте их и выполните генерацию целочисленной случайной величины в диапазоне [a; b]. Выведите результат на экран.
# # Ликбез: квадратная скобка - граница включается в диапазон; круглая скобка - граница исключается из диапазона.
# import random
# a, b = map(int, input().split())
# print(random.randint(a, b))


# # ________________    Задание 328    ____________________
# # На вход программе подается строка с названиями городов, записанных через пробел. Прочитайте эту строку, сформируйте список из названий городов и выберите из этого списка один город случайным образом. Отобразите выбранный город на экране.
# import random
# cities = input().split()
# print(random.choice(cities))


# # ________________    Задание 329    ____________________
# # На вход программе подается таблица целых чисел, записанных через пробел. В программе уже реализовано чтение ее строк:
# # lst_in = list(map(str.strip, sys.stdin.readlines()))
# # Необходимо преобразовать список строк lst_in в двумерный список чисел. Затем, в полученном списке (таблице) перемешать столбцы, используя функции shuffle и zip. Результат вывести на экран (также в виде таблицы). При выводе в конце строк не должно быть пробелов.
# import random
# random.seed(1)
# lst_in = ['1 2 3 4', '5 6 7 8', '9 8 6 7']
# lst = list(map(int, i.split()) for i in lst_in)
# z = list(zip(*lst))
# random.shuffle(z)
# z = list(zip(*z))
# for i in z:
#     print(*i)


# # ------  решение другого ученика  ------
# import sys
# import random
# # установка "зерна" датчика случайных чисел, чтобы получались одни и те же случайные величины
# random.seed(1)
#
# # считывание списка из входного потока
# lst_in = list(map(str.strip, sys.stdin.readlines()))
#
# # здесь продолжайте программу
# lst = list(zip(*map(str.split, lst_in)))
# random.shuffle(lst)
# [print(*i) for i in zip(*lst)]


# # ________________    Задание 330    ____________________
# # На вход программе подается строка с именами студентов, записанными через пробел. Требуется прочитать эти имена и случайным образом выбрать трех студентов из этого списка, используя функцию sample. (Полагается, что в исходном списке более трех студентов). Результат вывести на экран в одну строчку через пробел.
# import random
# random.seed(1)
# lst_in = input().split()
# print(*random.sample(lst_in, 3))



# # ________________    Задание 331    ____________________
# В программе инициализируется двумерное игровое поле размером N x N (N - натуральное число читается из входного потока), представленное в виде вложенного списка:
# P = [[0] * N for i in range(N)]
# Требуется расставить на поле P случайным образом M = 10 единиц (целочисленных) так, чтобы они не соприкасались друг с другом (то есть, вокруг каждой единицы должны быть нули, либо граница поля).
# P.S. Поле на экран выводить не нужно (вообще ничего не нужно выводить), только сформировать.
# # не прошло проверку
# import random
# N = int(input())
# P = [[0] * N for i in range(N)]
# counter = 0
#
# def counter_ab():
#     global counter
#     a = random.randint(0, N)
#     b = random.randint(0, N)
#     while counter < 10:
#         if a == 0 and b == 0:
#             if P[a + 1][b] != 1 and P[a][b + 1] != 1 and P[a][b] != 1:
#                 P[a][b] = 1
#                 counter += 1
#         if a == 0 and b == N:
#             if P[a + 1][b] != 1 and P[a][b - 1] != 1 and P[a][b] != 1:
#                 P[a][b] = 1
#                 counter += 1
#         if a == N and b == 0:
#             if P[a - 1][b] != 1 and P[a][b + 1] != 1 and P[a][b] != 1:
#                 P[a][b] = 1
#                 counter += 1
#         if a == N and b == N:
#             if P[a - 1][b] != 1 and P[a][b - 1] != 1 and P[a][b] != 1:
#                 P[a][b] = 1
#                 counter += 1
#
#         if P[a][b - 1] != 1 and P[a][b + 1] != 1 and P[a - 1][b] != 1 and P[a + 1][b] != 1 and P[a][b] != 1:
#             P[a][b] = 1
#             counter += 1
#
#         a = random.randint(1, N - 2)
#         b = random.randint(1, N - 2)
#     return P
#
# P = counter_ab()
# print(P)

import random
random.seed(1)
N = int(input())
P = [[0] * N for i in range(N)]
counter = 0
while counter < 10:
    i = random.randint(0, N)
    j = random.randint(0, N)
    if i == 0:
        if sum(P[i][j - 1: j + 1]) + sum(P[i + 1][j - 1: j + 1]) == 0:
            P[i][j] = 1
            counter += 1
    elif i == N:
        if sum(P[i][j - 1: j + 1]) + sum(P[i - 1][j - 1: j + 1]) == 0:
            P[i][j] = 1
            counter += 1
    elif j == 0:
        if sum(P[i - 1][j: j + 1]) + sum(P[i][j: j + 1]) + sum(P[i + 1][j: j + 1]) == 0:
            P[i][j] = 1
            counter += 1
    elif j == N:
        if sum(P[i - 1][j - 1: j]) + sum(P[i][j - 1: j]) + sum(P[i + 1][j - 1: j]) == 0:
            P[i][j] = 1
            counter += 1
    else:
        if sum(P[i - 1][j - 1: j + 1]) + sum(P[i][j - 1: j + 1]) + sum(P[i + 1][j - 1: j + 1]) == 0:
            P[i][j] = 1
            counter += 1




# # ------  решение другого ученика  ------
# k = 0
#
# while k < 10:
#     f = random.randint(0, N-1)
#     j = random.randint(0, N-1)
#
#     if f % 2 == 0 and j % 2 == 0 and P[f][j] != 1:
#         P[f][j] = 1
#         k += 1

